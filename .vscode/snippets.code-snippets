{
  "Main": {
    "scope": "python",
    "description": "Starter Kit",
    "prefix": "main",
    "body": [
      "import sys",
      "",
      "sys.setrecursionlimit(1000000)",
      "input = sys.stdin.readline",
      "",
      "",
      "def main() -> None:",
      "    $0",
      "",
      "",
      "if __name__ == \"__main__\":",
      "    main()"
    ]
  },
  "UnionFind": {
    "prefix": "UnionFind",
    "body": [
      "class UnionFind:",
      "    \"\"\"Union-Find Tree",
      "",
      "    Class implementation of disjoint-set data structure",
      "",
      "    Attributes:",
      "        _parent (List[int]): A list retaining the parent of the node.",
      "        _rank (List[int]): A list retaining rank of the subtree to which",
      "        the node belongs.",
      "        _size (List[int]): A list retaining the size of the subtree to",
      "        which the node belongs.",
      "    \"\"\"",
      "",
      "    def __init__(self, N: int) -> None:",
      "        \"\"\"Constructor",
      "",
      "        Arg:",
      "            N (int): Number of nodes.",
      "        \"\"\"",
      "        self._parent: list[int] = [-1 for i in range(N)]",
      "        self._rank: list[int] = [0 for i in range(N)]",
      "        self._size: list[int] = [1 for i in range(N)]",
      "",
      "    def get_root(self, x: int) -> int:",
      "        \"\"\"Return the root of the tree to which x belongs",
      "",
      "        Arg:",
      "            x (int): Index of the node.",
      "",
      "        Return:",
      "            int: Index of the root of the node.",
      "        \"\"\"",
      "        if self._parent[x] == -1:",
      "            return x",
      "        else:",
      "            self._parent[x] = self.get_root(self._parent[x])",
      "            return self._parent[x]",
      "",
      "    # Return true if x and y belong to the same tree",
      "    def is_same(self, x: int, y: int) -> bool:",
      "        \"\"\"Return true if x and y belong to the same subtree.",
      "",
      "        Args:",
      "            x (int): Index of the node.",
      "            y (int): Index of the other node.",
      "",
      "        Return:",
      "            bool: True when two  nodes belong to the same subtree, false otherwise",
      "        \"\"\"",
      "        return self.get_root(x) == self.get_root(y)",
      "",
      "    def unite(self, x: int, y: int) -> bool:",
      "        \"\"\"Merge the group to which x belongs and the group to which y belongs",
      "",
      "        Args:",
      "            x (int): Index of the node.",
      "            y (int): Index of the other node.",
      "",
      "        Return:",
      "            bool: True when two nodes have successfully merged,",
      "            false when two nodes has been already belong same subtree.",
      "        \"\"\"",
      "        # Get root of x and y",
      "        rx = self.get_root(x)",
      "        ry = self.get_root(y)",
      "",
      "        # Do nothing when x and y are already in same group",
      "        if rx == ry:",
      "            return False",
      "",
      "        # Union by rank",
      "        # Make sure that the rank of ry side is small",
      "        if self._rank[rx] < self._rank[ry]:",
      "            rx, ry = ry, rx",
      "",
      "        # Make sure that ry is child of rx",
      "        self._parent[ry] = rx",
      "",
      "        # Compute rank of rx side",
      "        if self._rank[rx] == self._rank[ry]:",
      "            self._rank[rx] += 1",
      "",
      "        # Compute size of rx side",
      "        self._size[rx] += self._size[ry]",
      "",
      "        return True",
      "",
      "    def get_size(self, x: int) -> int:",
      "        \"\"\"Return size of the subtree to which x belongs.",
      "",
      "        Args:",
      "            x (int): Index of the node.",
      "",
      "        Return:",
      "            int: Size of the subtree to which x belongs.",
      "",
      "        \"\"\"",
      "",
      "        return self._size[self.get_root(x)]",
      ""
    ],
    "description": "UnionFind"
  },
  "EratosthenesSieve": {
    "prefix": "EratosthenesSieve",
    "body": [
      "class EratosthenesSieve:",
      "    \"\"\"",
      "    Class implementation of eratosthenes sieve",
      "    \"\"\"",
      "",
      "    def __init__(self, N: int) -> None:",
      "        \"\"\"",
      "        Constructor takes length of sieve",
      "        \"\"\"",
      "        self._N: int = N",
      "        self._is_prime: list[bool] = [True for i in range(N + 1)]",
      "        self._primes: list[int] = []",
      "        self._minimum_factor_of: list[int] = [-1 for i in range(N + 1)]",
      "",
      "        self._is_prime[0] = self._is_prime[1] = False",
      "        self._minimum_factor_of[1] = 1",
      "",
      "        for i in range(2, N + 1):",
      "            if not self._is_prime[i]:",
      "                continue",
      "",
      "            self._primes.append(i)",
      "            self._minimum_factor_of[i] = i",
      "",
      "            for j in range(2 * i, N + 1, i):",
      "                self._is_prime[j] = False",
      "",
      "                if self._minimum_factor_of[j] == -1:",
      "                    self._minimum_factor_of[j] = i",
      "",
      "    def factorize(self, N: int) -> list[tuple[int, int]]:",
      "        \"\"\"",
      "        Returns a list of pair of N prime factors and their exponents.",
      "        \"\"\"",
      "        if N > self._N:",
      "            return []",
      "",
      "        result: list[tuple[int, int]] = []",
      "        while N > 1:",
      "            p: int = self._minimum_factor_of[N]",
      "            exp: int = 0",
      "",
      "            while self._minimum_factor_of[N] == p:",
      "                N //= p",
      "                exp += 1",
      "",
      "            result.append((p, exp))",
      "",
      "        return result",
      "",
      "    def divisors(self, N: int) -> list[int]:",
      "        \"\"\"",
      "        Returns a list of N's divisors.",
      "        \"\"\"",
      "        if N > self._N:",
      "            return []",
      "",
      "        result: list[int] = [1]",
      "        factors: list[tuple[int, int]] = self.factorize(N)",
      "",
      "        for p, exp in factors:",
      "            size: int = len(result)",
      "            for i in range(size):",
      "                v: int = 1",
      "                for j in range(exp):",
      "                    v *= p",
      "                    result.append(result[i] * v)",
      "",
      "        return sorted(result)",
      "",
      "    def primes(self) -> list[int]:",
      "        \"\"\"",
      "        Returns a list of prime numbers up to N.",
      "        \"\"\"",
      "        return self._primes",
      "",
      "    def is_prime(self) -> list[bool]:",
      "        \"\"\"",
      "        Returns a list of boolean indicating whether the number is prime or not up to N.",
      "        \"\"\"",
      "        return self._is_prime",
      ""
    ],
    "description": "EratosthenesSieve"
  },
  "divisors": {
    "prefix": "divisors",
    "body": [
      "def divisors(N: int) -> list[int]:",
      "    result: list[int] = []",
      "",
      "    i: int = 1",
      "    while i * i <= N:",
      "        if N % i == 0:",
      "            result.append(i)",
      "",
      "            if N // i != i:",
      "                result.append(N // i)",
      "        i += 1",
      "",
      "    return sorted(result)"
    ],
    "description": "divisors"
  },
  "factorize": {
    "prefix": "factorize",
    "body": [
      "def factorize(N: int) -> list[tuple[int, int]]:",
      "    result: list[tuple[int, int]] = []",
      "",
      "    i: int = 2",
      "    while i * i <= N:",
      "        if N % i == 0:",
      "            exp: int = 0",
      "",
      "            while N % i == 0:",
      "                N //= i",
      "                exp += 1",
      "",
      "            result.append((i, exp))",
      "        i += 1",
      "",
      "    if N != 1:",
      "        result.append((N, 1))",
      "",
      "    return result"
    ],
    "description": "factorize"
  },
  "Input a number": {
    "prefix": "anumber",
    "body": ["$0: int = int(input())"],
    "description": "Input one number via standard input"
  },
  "Input some numbers": {
    "prefix": "somenumber",
    "body": "$1, $0 = map(int, input().split())",
    "description": "Input some numbers"
  },
  "Input 1D Vector": {
    "prefix": "alist",
    "body": "$0: list[int] = [int(v.strip()) for v in input().split()]",
    "description": "Input 1D vector which contains integer as element"
  },
  "Input vector of vector": {
    "prefix": "listlist",
    "body": "$1: list[list[int]] = [[int(v.strip()) for v in input().split()] for i in range($0)]",
    "description": "Input 1D vector which contains 1D vector of integer"
  },
  "Input a string": {
    "prefix": "astring",
    "body": ["$1: str = input().rstrip()"],
    "description": "Input one string via standard input"
  },
  "Binominal-coefficient implementation": {
    "prefix": "BinominalCoefficient",
    "body": [
      "class BinominalCoefficient:",
      "    def __init__(self, N: int, mod: int) -> None:",
      "        self._N: int = N",
      "        self._mod: int = mod",
      "        self._factorial: list[int] = [1 for i in range(N + 1)]",
      "        self._inverse_element: list[int] = [1 for i in range(N + 1)]",
      "        self._inverse_factorial: list[int] = [1 for i in range(N + 1)]",
      "",
      "        for i in range(2, self._N + 1):",
      "            self._factorial[i] = self._factorial[i - 1] * i % self._mod",
      "            self._inverse_element[i] = (",
      "                self._mod",
      "                - self._inverse_element[self._mod % i]",
      "                * (self._mod // i)",
      "                % self._mod",
      "            )",
      "            self._inverse_factorial[i] = (",
      "                self._inverse_factorial[i - 1]",
      "                * self._inverse_element[i]",
      "                % self._mod",
      "            )",
      "",
      "    def nCr(self, n: int, r: int) -> int:",
      "        if n > self._N or n < r or n < 0 or r < 0:",
      "            return 0",
      "",
      "        return (",
      "            self._factorial[n]",
      "            * (",
      "                self._inverse_factorial[r]",
      "                * self._inverse_factorial[n - r]",
      "                % self._mod",
      "            )",
      "            % self._mod",
      "        )",
      ""
    ],
    "description": "Binominal-coefficient implementation"
  },
  "mod1000000007": {
    "prefix": "mod1000000007",
    "body": "mod: int = 1000000007",
    "description": "modulo for competitive programing"
  },
  "mod998244353": {
    "prefix": "mod998244353",
    "body": "mod: int = 998244353",
    "description": "modulo for competitive programing"
  },
  "LazySegmentTree": {
    "prefix": "LazySegmentTree",
    "body": [
      "from collections.abc import Callable",
      "from typing import Generic, TypeVar",
      "",
      "# Type of the element of segment tree",
      "S = TypeVar(\"S\")",
      "# Type of the operator",
      "F = TypeVar(\"F\")",
      "",
      "",
      "class LazySegmentTree(Generic[S, F]):",
      "    \"\"\"Segment Tree with Lazy Propagation",
      "",
      "    Non-recursive, and abstracted lazy segment tree implementation.",
      "",
      "    Attributes:",
      "        _N (int): Number of the elements managed by segment tree.",
      "        _op (Callable[[S, S], S]): A function object representing the binary operator.",
      "        _e (Callable[[], int]): A function object which returns identity element.",
      "        _mapping (Callable[[F, S], S]): A function object representing the mapping. mapping() takes the operator f and target element s, and returns the result.",
      "        _composition (Callable[[F, F], F]): A function object representing the composition of maps. composition() takes two operator, and returns composited operator.",
      "        _id (Callable[[], F]): A function object representing identity mapping.",
      "        _log (int): The logarithm of size of segment tree base 2.",
      "        _size (int): Size of the list that representing binary tree object.",
      "        _data (list[S]): A list of the entities representing segment tree.(1-indexed)",
      "        _lazy (list[F]): A list for lazy propagation. lazy[k] holds the operation performed in the segment corresponding to the data[k] which haven't yet been applied to the nodes below the data[k].",
      "    \"\"\"",
      "",
      "    def __init__(",
      "        self,",
      "        op: Callable[[S, S], S],",
      "        e: Callable[[], S],",
      "        mapping: Callable[[F, S], S],",
      "        composition: Callable[[F, F], F],",
      "        id: Callable[[], F],",
      "        A: list[S],",
      "    ) -> None:",
      "        \"\"\"",
      "        Args:",
      "            op (Callable[[S, S], S])",
      "            e (Callable[[], S])",
      "            mapping (Callable[[F, S], S])",
      "            composition (Callable[[F, F], F])",
      "            id (Callable[[], F])",
      "            A (list[S])",
      "        \"\"\"",
      "",
      "        self._N: int = len(A)",
      "        self._op: Callable[[S, S], S] = op",
      "        self._e: Callable[[], S] = e",
      "        self._mapping: Callable[[F, S], S] = mapping",
      "        self._composition: Callable[[F, F], F] = composition",
      "        self._id: Callable[[], F] = id",
      "        self._log: int = (self._N - 1).bit_length()",
      "        self._size: int = 1 << self._log",
      "        # Initialize each element of the list with identity element.",
      "        self._data: list[S] = [self._e()] * (2 * self._size)",
      "        self._lazy: list[F] = [self._id()] * self._size",
      "",
      "        # Initialize leaves with given list A.",
      "        self._data[self._size : self._size + self._N] = A",
      "",
      "        # Update all nodes (not leaf).",
      "        for i in range(self._size - 1, 0, -1):",
      "            self._update(i)",
      "",
      "    def set(self, k: int, x: S) -> None:",
      "        \"\"\"Set x into the specified leaf.",
      "",
      "        Args:",
      "            k (int): The index of the leaf(0-indexed).",
      "        \"\"\"",
      "",
      "        # Move to the leaf.",
      "        k += self._size",
      "",
      "        # Propagate pending operator from the root to the leaf.",
      "        for i in range(self._log, 0, -1):",
      "            self._propagate(k >> i)",
      "",
      "        # Update value of the element from the leaf to the root.",
      "        for i in range(1, self._log + 1):",
      "            self._update(k >> i)",
      "",
      "    def get(self, k: int) -> S:",
      "        \"\"\"Get the value of the specified leaf.",
      "",
      "        Args:",
      "            k (int): The index of the leaf(0-indexed).",
      "",
      "        Returns:",
      "            S: Value of the specified leaf.",
      "        \"\"\"",
      "",
      "        # Move to the leaf.",
      "        k += self._size",
      "",
      "        # Propagate pending operator from the root to the leaf.",
      "        for i in range(self._log, 0, -1):",
      "            self._propagate(k >> i)",
      "",
      "        # Return the value.",
      "        return self._data[k]",
      "",
      "    def prod(self, l: int, r: int) -> S:",
      "        \"\"\"Returns op(A[l], ..., A[r - 1]).",
      "",
      "        Returns the result of applying the binary operator to the interval [l, r).",
      "",
      "        Args:",
      "            l (int): Left end of the given interval.",
      "            r (int): Right end of the given interval. it doesn't not include the right end.",
      "",
      "        Returns:",
      "            S: The result.",
      "        \"\"\"",
      "",
      "        # When invalid interval was given",
      "        if l >= r:",
      "            return self._e()",
      "",
      "        # Move to leaf",
      "        l += self._size",
      "        r += self._size",
      "",
      "        # Variable to hold the left result",
      "        left_result: S = self._e()",
      "        # Variable to hold the right result",
      "        right_result: S = self._e()",
      "",
      "        # Propagate pending operator from the root to the leaf",
      "        # for calculate the production",
      "        for i in range(self._log, 0, -1):",
      "            # In the subtree containing the l, when the l is the leftmost node,",
      "            # don't have to propagate. Because the root of the subtree has all",
      "            # information of l.",
      "            if ((l >> i) << i) != l:",
      "                self._propagate(l >> i)",
      "            # Same to above.",
      "            if ((r >> i) << i) != r:",
      "                self._propagate((r - 1) >> i)",
      "",
      "        # Find all nodes covering the given interval.",
      "        while l < r:",
      "            # If l is right child",
      "            if l & 1:",
      "                # Calculate result.",
      "                left_result = self._op(left_result, self._data[l])",
      "                # Move to elder brother.",
      "                l += 1",
      "",
      "            # If r is right child",
      "            if r & 1:",
      "                # Move to little brother.",
      "                r -= 1",
      "                # Calculate result.",
      "                right_result = self._op(right_result, self._data[r])",
      "",
      "            # Move to parent.",
      "            l >>= 1",
      "            r >>= 1",
      "",
      "        # Return the result.",
      "        return self._op(left_result, right_result)",
      "",
      "    def prod_all(self) -> S:",
      "        \"\"\"Returns op(A[0], ..., A[N - 1]).",
      "",
      "        Return the result of applying the binary operator to all monoids.",
      "",
      "        Returns:",
      "            S: The operation result.",
      "        \"\"\"",
      "        return self._data[1]",
      "",
      "    def apply(self, k: int, f: F) -> None:",
      "        \"\"\"Apply the mapping to single leaf.",
      "",
      "        Apply the mapping to the single leaf with specified index.",
      "",
      "        Args:",
      "            k (int): Index of the leaf(0-indexed).",
      "            f (F): The value to be acted on the leaf.",
      "        \"\"\"",
      "",
      "        # Move to leaf.",
      "        k += self._size",
      "",
      "        # Propagate pending operator from the root to the leaf.",
      "        for i in range(self._log, 0, -1):",
      "            self._propagate(k >> i)",
      "",
      "        # Apply the mapping to the leaf.",
      "        self._data[k] = self._mapping(f, self._data[k])",
      "",
      "        # Update ancestors.",
      "        for i in range(1, self._log + 1):",
      "            self._update(k >> i)",
      "",
      "    def apply_each(self, l: int, r: int, f: F) -> None:",
      "        \"\"\"Apply the mapping to each leaves of the specified interval.",
      "",
      "        Apply the mapping to each leaves of the specified interval [l, r).",
      "",
      "        Args:",
      "            l (int): Left end of the given interval.",
      "            r (int): Right end of the given interval.",
      "            f (F): The value to be acted on the leaves.",
      "        \"\"\"",
      "",
      "        # When invalid interval was given",
      "        if l >= r:",
      "            return",
      "",
      "        # Move to leaf.",
      "        l += self._size",
      "        r += self._size",
      "",
      "        # Propagate pending operator from the root to the leaf",
      "        # for calculate the production",
      "        for i in range(self._log, 0, -1):",
      "            # In the subtree containing the l, when the l is the leftmost node,",
      "            # don't have to propagate. Because the root of the subtree has all",
      "            # information of l.",
      "            if ((l >> i) << i) != l:",
      "                self._propagate(l >> i)",
      "            # Same to above.",
      "            if ((r >> i) << i) != r:",
      "                self._propagate((r - 1) >> i)",
      "",
      "        # Copy the variable for temporary calculation.",
      "        left: int = l",
      "        right: int = r",
      "        # Find all nodes covering the given interval, and apply the mapping to them.",
      "        while left < right:",
      "            # If left is right child",
      "            if left & 1:",
      "                # Apply the mapping.",
      "                self._reflect(left, f)",
      "                # Move to elder brother.",
      "                left += 1",
      "",
      "            # If right is right child",
      "            if right & 1:",
      "                # Move to little brother.",
      "                right -= 1",
      "                # Apply the mapping.",
      "                self._reflect(right, f)",
      "",
      "            # Move to parent.",
      "            left >>= 1",
      "            right >>= 1",
      "",
      "        # Update value of the ancestors.",
      "        for i in range(1, self._log + 1):",
      "            # In the subtree containing the l, when the l is the leftmost node,",
      "            # don't have to update. Because the root of the subtree has all",
      "            # information of l.",
      "            if ((l >> i) << i) != l:",
      "                self._update(l >> i)",
      "            # Same to above.",
      "            if ((r >> i) << i) != r:",
      "                self._update(r >> i)",
      "",
      "    def _reflect(self, k: int, f: F) -> None:",
      "        \"\"\"Reflect the operation on the node.",
      "",
      "        Reflect the specified operator f on the node data[k], and if the node is leaf,",
      "        combine the operator f with lazy[k].",
      "",
      "        Args:",
      "            k (int): The index of the node (0-indexed).",
      "            f (F): The operator.",
      "        \"\"\"",
      "",
      "        # Reflect the operator on the node.",
      "        self._data[k] = self._mapping(f, self._data[k])",
      "",
      "        # When k is not leaf",
      "        if k < self._size:",
      "            # Combine the operator f with lazy[k]",
      "            self._lazy[k] = self._composition(f, self._lazy[k])",
      "",
      "    def _propagate(self, k: int) -> None:",
      "        \"\"\"Propagate pending operator to each child.",
      "",
      "        Propagate pending operator lazy[k] to each child, and reset lazy[k].",
      "",
      "        Args:",
      "            k (int): The index of the node (0-indexed).",
      "        \"\"\"",
      "",
      "        # Propagate operator lazy[k] to left child.",
      "        self._reflect(2 * k, self._lazy[k])",
      "        # Propagate operator lazy[k] to right child.",
      "        self._reflect(2 * k + 1, self._lazy[k])",
      "",
      "        # Reset lazy[k]",
      "        self._lazy[k] = self._id()",
      "",
      "    def _update(self, k: int) -> None:",
      "        \"\"\"Update the element.",
      "",
      "        Update value of the element with the value of the child node.",
      "",
      "        Args:",
      "            k (int): The index of the node (0-indexed).",
      "        \"\"\"",
      "        self._data[k] = self._op(self._data[2 * k], self._data[2 * k + 1])",
      ""
    ],
    "description": "LazySegmentTree"
  },
  "SegmentTree": {
    "prefix": "SegmentTree",
    "body": [
      "from collections.abc import Callable, Iterator",
      "from typing import Generic, TypeVar",
      "",
      "# Type of the element of segment tree",
      "S = TypeVar(\"S\")",
      "",
      "",
      "class SegmentTree(Generic[S]):",
      "    \"\"\"Segment Tree",
      "",
      "    Non-recursive, and abstracted segment tree implementation.",
      "",
      "    Attributes:",
      "        _N (int): Number of the elements managed by segment tree.",
      "        _op (Callable[[S, S], S]): A function object representing the binary operator.",
      "        _e (Callable[[], int]): A function object which returns identity element.",
      "        _log (int): The logarithm of size of segment tree base 2. Also this represent the height of the tree.",
      "        _size (int): Number of the leaves of the tree",
      "        _data (list[S]): A list of the entities representing segment tree.(1-indexed)",
      "    \"\"\"",
      "",
      "    def __init__(",
      "        self,",
      "        op: Callable[[S, S], S],",
      "        e: Callable[[], S],",
      "        A: list[S],",
      "    ) -> None:",
      "        \"\"\"",
      "        Args:",
      "            op (Callable[[S, S], S]): A function representing the binary operator.",
      "            e (Callable[[], S]): A function representing identity element.",
      "            A (list[S]): A list containing the initial values of leaves.",
      "        \"\"\"",
      "        self._N = len(A)",
      "        self._op = op",
      "        self._e = e",
      "        # Calculate tree size.",
      "        self._log: int = (self._N - 1).bit_length()",
      "        self._size: int = 1 << self._log",
      "        # Segment tree is represented by a list of length 2N",
      "        # because it's a full binary tree.",
      "        self._data: list[S] = [self._e()] * (2 * self._size)",
      "",
      "        # Initialize leaves with given list A.",
      "        self._data[self._size : self._size + self._N] = A",
      "",
      "        # Update all non-leaf nodes.",
      "        for i in range(self._size - 1, 0, -1):",
      "            self._update(i)",
      "",
      "    def __setitem__(self, key: int, value: S) -> None:",
      "        \"\"\"Point Update: Set the value into the specified leaf.",
      "",
      "        Args:",
      "            key (int): The index of the leaf (0-indexed).",
      "            value (S): The value to apply.",
      "        \"\"\"",
      "        # Move to the leaf.",
      "        key += self._size",
      "",
      "        # Set the value of the leaf",
      "        self._data[key] = value",
      "",
      "        # Update value of the element from the leaf to the root.",
      "        for i in range(1, self._log + 1):",
      "            self._update(key >> i)",
      "",
      "    def __getitem__(self, key: int | slice) -> S:",
      "        \"\"\"Point Acquisition: Get the production of the specified point of interval.",
      "",
      "        Args:",
      "            key (int or slice): The index of the leaf, or interval (0-indexed).",
      "            if key is int, return the value of the leaf.",
      "            if key is slice, return the product of the interval.",
      "",
      "        Return:",
      "            S: The product.",
      "        \"\"\"",
      "        # Type check",
      "        if isinstance(key, int):",
      "            # When key is int, return the value of the leaf.",
      "            return self._data[key + self._size]",
      "        elif isinstance(key, slice):",
      "            # Value check",
      "            l: int = 0 if key.start is None else key.start",
      "            r: int = self._N if key.stop is None else key.stop",
      "",
      "            if not (0 <= l < self._size and 0 <= r <= self._size):",
      "                raise IndexError",
      "",
      "            # WHen key is slice, return the value of the leaf",
      "",
      "            return self.prod(l, r)",
      "",
      "    def prod(self, l: int, r: int) -> S:",
      "        \"\"\"Returns op(A[l], ..., A[r - 1]).",
      "",
      "        Returns the product of the interval [l, r).",
      "",
      "        Args:",
      "            l (int): Left end of the given interval.",
      "            r (int): Right end of the given interval. it doesn't include the right end.",
      "",
      "        Return:",
      "            S: The product.",
      "        \"\"\"",
      "",
      "        # When invalid interval was given",
      "        if l >= r:",
      "            return self._e()",
      "",
      "        # Move to leaf",
      "        l += self._size",
      "        r += self._size",
      "",
      "        # Variable to hold the left result",
      "        left_result: S = self._e()",
      "        # Variable to hold the right result",
      "        right_result: S = self._e()",
      "",
      "        # Find all nodes covering the given interval.",
      "        while l < r:",
      "            # If l is right child",
      "            if l & 1:",
      "                # Calculate result.",
      "                left_result = self._op(left_result, self._data[l])",
      "                # Move to elder sibling.",
      "                l += 1",
      "",
      "            # If r is right child",
      "            if r & 1:",
      "                # Move to little sibling.",
      "                r -= 1",
      "                # Calculate result.",
      "                right_result = self._op(self._data[r], right_result)",
      "",
      "            # Move to parent.",
      "            l >>= 1",
      "            r >>= 1",
      "",
      "        # Return the result.",
      "        return self._op(left_result, right_result)",
      "",
      "    def _update(self, k: int) -> None:",
      "        \"\"\"Update the element.",
      "",
      "        Update value of the element with the value of the child node.",
      "",
      "        Args:",
      "            k (int): The index of the node (0-indexed).",
      "        \"\"\"",
      "        self._data[k] = self._op(self._data[2 * k], self._data[2 * k + 1])",
      "",
      "    def __len__(self) -> int:",
      "        \"\"\"Return the size of tree.\"\"\"",
      "        return 2 * self._size",
      "",
      "    def __iter__(self) -> Iterator[S]:",
      "        \"\"\"Return the leaves iterator corresponding to A\"\"\"",
      "        for d in self._data[self._size : self._size + self._N]:",
      "            yield d",
      ""
    ],
    "description": "SegmentTree"
  },
  "WeightedUnionFind": {
    "prefix": "WeightedUnionFind",
    "body": [
      "from typing import Generic, TypeVar",
      "",
      "# Type of the weight for Weighted Union-Find Tree",
      "T = TypeVar(\"T\", int, float)",
      "",
      "",
      "class WeightedUnionFind(Generic[T]):",
      "    \"\"\"",
      "    Weighted Union-Find Tree implementation.",
      "",
      "    Attributes:",
      "        _N (int): Number of nodes.",
      "        _e (T): Identity element of the abelian group. Normally assigned 0.",
      "        _parent (list[int]): list retaining the parent node of the node.",
      "        _rank (list[int]): list retaining the rank of the node.",
      "        _diff_weight (list[T]): list retaining the weight difference between the root of the subtree.",
      "    \"\"\"",
      "",
      "    def __init__(self, N: int, e: T) -> None:",
      "        \"\"\"",
      "        Args:",
      "            N (int): Number of nodes.",
      "            e (T): Identity element of the abelian group. Normally assigned 0.",
      "        \"\"\"",
      "        self._N: int = N",
      "        self._e: T = e",
      "        self._parent: list[int] = [i for i in range(N)]",
      "        self._rank: list[int] = [0 for i in range(N)]",
      "        self._diff_weight: list[T] = [e for i in range(N)]",
      "",
      "    def root(self, v: int) -> int:",
      "        \"\"\"",
      "        Returns the root of the subtree to which the node v is belonging.",
      "        In addition, route-compression is also performed.",
      "",
      "        Args:",
      "            v (int): The index of the specified node.",
      "",
      "        Returns:",
      "            int: The index of the root.",
      "        \"\"\"",
      "        # Return itself if node v is the root.",
      "        if self._parent[v] == v:",
      "            return v",
      "",
      "        # Get the root recursively.",
      "        r: int = self.root(self._parent[v])",
      "        # Accumulate weight.",
      "        self._diff_weight[v] += self._diff_weight[self._parent[v]]",
      "        # Update the list.",
      "        self._parent[v] = r",
      "",
      "        # Return the root.",
      "        return r",
      "",
      "    def weight(self, v: int) -> T:",
      "        \"\"\"",
      "        Returns the weight difference between the root and the node.",
      "",
      "        Args:",
      "            v (int): The index of the node.",
      "",
      "        \"\"\"",
      "        # Conduct route-compression.",
      "        self.root(v)",
      "",
      "        # Return the difference of weight.",
      "        return self._diff_weight[v]",
      "",
      "    def is_same(self, x: int, y: int) -> bool:",
      "        \"\"\"",
      "        Determine if they are in same group.",
      "",
      "        Args:",
      "            x (int): The index of the node.",
      "            y (int): The index of the other node.",
      "",
      "        Returns:",
      "            bool: True if x and y are belonging same group. Otherwise, False.",
      "        \"\"\"",
      "        return self.root(x) == self.root(y)",
      "",
      "    def unite(self, x: int, y: int, w: T) -> bool:",
      "        \"\"\"",
      "        Merge specified two nodes.",
      "",
      "        Args:",
      "            x (int): The index of the node.",
      "            y (int): The index of the other node.",
      "            w (T): The weight difference between x and y.",
      "",
      "        Returns:",
      "            bool: False if x and y are already in same group.",
      "        \"\"\"",
      "        # Compensate the weight because each root is merged in fact.",
      "        w += self.weight(x)",
      "        w -= self.weight(y)",
      "",
      "        # Move to each root.",
      "        x = self.root(x)",
      "        y = self.root(y)",
      "",
      "        # Return false if x and y are already in same group.",
      "        if x == y:",
      "            return False",
      "",
      "        # Swap so that the rank of x is higher.",
      "        if self._rank[x] < self._rank[y]:",
      "            x, y = y, x",
      "            w = -w",
      "",
      "        # If the two trees are the same rank, the rank increases by 1 after merge.",
      "        if self._rank[x] == self._rank[y]:",
      "            self._rank[x] += 1",
      "",
      "        # Update parent.",
      "        self._parent[y] = x",
      "",
      "        # Update weight.",
      "        self._diff_weight[y] = w",
      "",
      "        # Successfully merged.",
      "        return True",
      "",
      "    def diff(self, x: int, y: int) -> T:",
      "        return self.weight(y) - self.weight(x)",
      ""
    ],
    "description": "WeightedUnionFind"
  },
  "compress": {
    "prefix": "compress",
    "body": [
      "def compress(A: list[int]) -> list[int]:",
      "    X: list[int] = sorted(set(A))",
      "    D: dict[int, int] = {x: i for i, x in enumerate(X)}",
      "    return [D[a] for a in A]",
      ""
    ],
    "description": "compress"
  },
  "Dijkstra": {
    "prefix": "Dijkstra",
    "body": [
      "class Dijkstra:",
      "    \"\"\"",
      "    Dijkstra method implementation.",
      "",
      "    Attributes:",
      "        N (int): Number of the nodes in the graph.",
      "        graph (list[list[tuple[int, int]]]): Adjacency-list representation of the graph.",
      "        distance (list[int]): A list retains distance of the shortest path from start to the node.",
      "        previous (list[int]): A list retains previous node index of the node on the shortest path.",
      "    \"\"\"",
      "",
      "    def __init__(self, graph: list[list[tuple[int, int]]]) -> None:",
      "        \"\"\"",
      "        Args:",
      "            graph (list[list[tuple[int, int]]]): Adjacency-list representation of the graph.",
      "        \"\"\"",
      "",
      "        # Copy the graph",
      "        self.graph: list[list[tuple[int, int]]] = graph",
      "        self.N: int = len(graph)",
      "",
      "        # Initialize each list",
      "        self.distance: list[int] = [1 << 60 for i in range(self.N)]",
      "        self.previous: list[int] = [-1 for i in range(self.N)]",
      "",
      "    def search(self, start_node: int) -> tuple[list[int], list[int]]:",
      "        \"\"\"",
      "        Calculate distance of the shortest path from start_node to each nodes.",
      "",
      "        Args:",
      "            start_node (int): The index of the start node.",
      "",
      "        Returns:",
      "            list[int]: A list retains distance of the shortest path.",
      "            list[int]: A list retains previous node of the node on the shortest path.",
      "        \"\"\"",
      "        # Heap queue",
      "        candidate: list[tuple[int, int]] = [(0, start_node)]",
      "        # Set zero to the distance of the start node.",
      "        self.distance[start_node] = 0",
      "",
      "        # Start to search dijkstra",
      "        while candidate:",
      "            d, node = heapq.heappop(candidate)",
      "",
      "            if d > self.distance[node]:",
      "                continue",
      "",
      "            for next_node, weight in self.graph[node]:",
      "                if self.distance[next_node] > self.distance[node] + weight:",
      "                    self.distance[next_node] = self.distance[node] + weight",
      "                    self.previous[next_node] = node",
      "                    heapq.heappush(",
      "                        candidate, (self.distance[next_node], next_node)",
      "                    )",
      "",
      "        return (self.distance, self.previous)",
      "",
      "    def restore_path(self, end_node: int) -> list[int]:",
      "        \"\"\"",
      "        Restore shortest path from start_node to end_node.",
      "",
      "        Args:",
      "            end_node (int): The index of the end node.",
      "",
      "        Returns:",
      "            list[int]: A list of the shortest path.",
      "        \"\"\"",
      "        path: list[int] = []",
      "        t: int = end_node",
      "        while t != -1:",
      "            path.append(t)",
      "            t = self.previous[t]",
      "",
      "        return list(reversed(path))",
      ""
    ],
    "description": "Dijkstra"
  },
  "Graph": {
    "prefix": "graph",
    "body": ["graph: list[list[int]] = [[] for i in range(N)]"],
    "description": "Input adjacency-list representation of non-weighted graph."
  },
  "WeigtedGraph": {
    "prefix": "weighted_graph",
    "body": ["graph: list[list[tuple[int, int]]] = [[] for i in range(N)]"],
    "description": "Input adjacency-list representation of weighted graph"
  },
  "SortedSet": {
    "prefix": "SortedSet",
    "body": [
      "T = TypeVar(\"T\", int, tuple)",
      "",
      "",
      "class SortedSet(Generic[T]):",
      "    \"\"\"Implementation of sorted set by square-root decomposition.",
      "",
      "    This class was implemented by refering to the following URL:",
      "    https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
      "",
      "    A (list[list[T]]): A list of list retaining the elements of the set.",
      "    size (int): The size of the set.",
      "    BUCKET_RATIO (int): The ratio of the number of buckets to the number of elements",
      "    in each bucket.",
      "    REBUILD_RATIO (int): Threshold for the ratio of buckets to rebuild.",
      "",
      "    \"\"\"",
      "",
      "    def __init__(self, a: Iterable[T] = []) -> None:",
      "        \"\"\"Create new sorted set from iterable.",
      "",
      "        Args:",
      "            a (Iterable[T]): The source for building sorted set.",
      "        \"\"\"",
      "        # Convert to list",
      "        a = list(a)",
      "        # When a is not sorted or unique, do so.",
      "        if not all(i < j for i, j in zip(a[0:-1], a[1:])):",
      "            a = sorted(set(a))",
      "",
      "        # Configure threshold of ratio",
      "        self.BUCKET_RATIO: int = 50",
      "        self.REBUILD_RATIO: int = 170",
      "",
      "        # Calculate and store length of sorted set.",
      "        self.size: int = len(a)",
      "        # Build the sorted set.",
      "        self._build(a)",
      "",
      "    def _build(self, a: Iterable[T] = None) -> None:",
      "        \"\"\"Evenly divide the container into buckets.",
      "",
      "        Args:",
      "            a (Iterable[T]): The source for building sorted set.",
      "        \"\"\"",
      "        # When the iterable was given, use it and override the container.",
      "        # Convert the given iterable into list.",
      "        if a is None:",
      "            a = list(self)",
      "        else:",
      "            a = list(a)",
      "",
      "        # Calculate length of the iterable.",
      "        size: int = len(a)",
      "        # Calculate each bucket size.",
      "        bucket_size: int = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
      "        # Divide the source into buckets.",
      "        self.A: list[list[T]] = [",
      "            a[size * i // bucket_size : size * (i + 1) // bucket_size]",
      "            for i in range(bucket_size)",
      "        ]",
      "",
      "    def __iter__(self) -> Iterator[T]:",
      "        for i in self.A:",
      "            for j in i:",
      "                yield j",
      "",
      "    def __reversed__(self) -> Iterator[T]:",
      "        for i in reversed(self.A):",
      "            for j in reversed(i):",
      "                yield j",
      "",
      "    def __len__(self) -> int:",
      "        return self.size",
      "",
      "    def __repr__(self) -> str:",
      "        return \"SortedSet\" + str(self.A)",
      "",
      "    def __str__(self) -> str:",
      "        s = str(list(self))",
      "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
      "",
      "    def _find_bucket(self, x: T) -> list[T]:",
      "        \"\"\"Find the bucket which should contain x.",
      "",
      "        Args:",
      "            x (T): The element of the set for search.",
      "",
      "        Return:",
      "            list[T]: The bucket which is containing x.",
      "        \"\"\"",
      "        for a in self.A:",
      "            if x <= a[-1]:",
      "                return a",
      "        return a",
      "",
      "    def __contains__(self, x: T) -> bool:",
      "        if self.size == 0:",
      "            return False",
      "",
      "        a = self._find_bucket(x)",
      "        i = bisect.bisect_left(a, x)",
      "        return i != len(a) and a[i] == x",
      "",
      "    def add(self, x: T) -> bool:",
      "        \"\"\"Add an element into the set.",
      "",
      "        Args:",
      "            x (T): The element to add.",
      "",
      "        Return:",
      "            bool: True if the element was added, or False.",
      "        \"\"\"",
      "        # WHen the set is empty:",
      "        if self.size == 0:",
      "            self.A = [[x]]",
      "            self.size = 1",
      "            return True",
      "",
      "        # Get the bucket in which x should be.",
      "        a = self._find_bucket(x)",
      "        # Get the index at which x should be inserted.",
      "        i = bisect.bisect_left(a, x)",
      "        # WHen  x is already exist in the set",
      "        if i != len(a) and a[i] == x:",
      "            return False",
      "",
      "        # Add x into the bucket.",
      "        a.insert(i, x)",
      "        # Increase size of the set.",
      "        self.size += 1",
      "        # When the ratio exceed the threshold, rebuild the set",
      "        if len(a) > len(self.A) * self.REBUILD_RATIO:",
      "            self._build()",
      "",
      "        return True",
      "",
      "    def discard(self, x: T) -> bool:",
      "        \"\"\"Remove an element from the set.",
      "",
      "        Args:",
      "            x (T): The element to remove.",
      "",
      "        Return:",
      "            bool: True if the element was successfully removed.",
      "        \"\"\"",
      "        # When the set is empty:",
      "        if self.size == 0:",
      "            return False",
      "",
      "        # Get the bucket which is containing x.",
      "        a = self._find_bucket(x)",
      "        # Get the index of x.",
      "        i = bisect.bisect_left(a, x)",
      "",
      "        # When the bucket doesn't have x:",
      "        if i == len(a) or a[i] != x:",
      "            return False",
      "",
      "        # Remove x.",
      "        a.pop(i)",
      "        # Decrease size of the set.",
      "        self.size -= 1",
      "        # If the bucket become empty, rebuild the container.",
      "        if len(a) == 0:",
      "            self._build()",
      "",
      "        return True",
      "",
      "    def lt(self, x: T) -> T | None:",
      "        \"\"\"Find the largest element less than x.",
      "",
      "        Args:",
      "            x (T): The element for search.",
      "",
      "        Return:",
      "            T: The largest element less than x.",
      "            If it doesn't exist, return None.",
      "        \"\"\"",
      "        for a in reversed(self.A):",
      "            if a[0] < x:",
      "                return a[bisect.bisect_left(a, x) - 1]",
      "        return None",
      "",
      "    def le(self, x: T) -> T | None:",
      "        \"\"\"Find the largest element less than or equal to  x.",
      "",
      "        Args:",
      "            x (T): The element for search.",
      "",
      "        Return:",
      "            T: The largest element less than or equal to  x.",
      "            If it doesn't exist, return None.",
      "        \"\"\"",
      "        for a in reversed(self.A):",
      "            if a[0] <= x:",
      "                return a[bisect.bisect_left(a, x) - 1]",
      "        return None",
      "",
      "    def gt(self, x: T) -> T | None:",
      "        \"\"\"Find the smallest element greater than x.",
      "",
      "        Args:",
      "            x (T): The element for search.",
      "",
      "        Return:",
      "            T: The smallest element greater than x.",
      "            If it doesn't exist, return None.",
      "        \"\"\"",
      "        for a in self.A:",
      "            if a[-1] > x:",
      "                return a[bisect.bisect_right(a, x)]",
      "        return None",
      "",
      "    def ge(self, x: T) -> T | None:",
      "        \"\"\"Find the smallest element greater than or equal to  x.",
      "",
      "        Args:",
      "            x (T): The element for search.",
      "",
      "        Return:",
      "            T: The smallest element greater than or equal to  x.",
      "            If it doesn't exist, return None.",
      "        \"\"\"",
      "        for a in self.A:",
      "            if a[-1] >= x:",
      "                return a[bisect.bisect_right(a, x)]",
      "",
      "        return None",
      "",
      "    def __getitem__(self, x: int) -> T:",
      "        \"\"\"Return the x-th element in the set.",
      "",
      "        Raise IndexError when it doesn't exist.",
      "",
      "        \"\"\"",
      "        if x < 0:",
      "            x += self.size",
      "",
      "        if x < 0:",
      "            raise IndexError",
      "",
      "        for a in self.A:",
      "            if x < len(a):",
      "                return a[x]",
      "            x -= len(a)",
      "        raise IndexError",
      "",
      "    def index(self, x: T) -> int:",
      "        \"\"\"Count the number of elements which is less than x.",
      "",
      "        Args:",
      "            x (T): The element fot search.",
      "",
      "        Return:",
      "            int: The number of elements which is less than x.",
      "        \"\"\"",
      "        result: int = 0",
      "        for a in self.A:",
      "            if a[-1] >= x:",
      "                return result + bisect.bisect_left(a, x)",
      "            result += len(a)",
      "",
      "        return result",
      "",
      "    def index_right(self, x: T) -> int:",
      "        \"\"\"Count the number of elements which is greater than or equal to x.",
      "",
      "        Args:",
      "            x (T): The element fot search.",
      "",
      "        Return:",
      "            int: The number of elements which is greater than or equal to x.",
      "        \"\"\"",
      "        result: int = 0",
      "        for a in self.A:",
      "            if a[-1] > x:",
      "                return result + bisect.bisect_right(a, x)",
      "            result += len(a)",
      "",
      "        return result",
      ""
    ],
    "description": "SortedSet"
  },
  "SortedMultiSet": {
    "prefix": "SortedMultiSet",
    "body": [
      "T = TypeVar(\"T\", int, tuple)",
      "",
      "",
      "class SortedMultiSet(Generic[T]):",
      "    \"\"\"Implementation of sorted multi set by square-root decomposition.",
      "",
      "    This class was implemented by referring to the following URL:",
      "    https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
      "",
      "    A (list[list[T]]): A list of list retaining the elements of the set.",
      "    size (int): The size of the set.",
      "    BUCKET_RATIO (int): The ratio of the number of buckets to the number of elements",
      "    in each bucket.",
      "    REBUILD_RATIO (int): Threshold for the ratio of buckets to rebuild.",
      "",
      "    \"\"\"",
      "",
      "    def __init__(self, a: Iterable[T] = []) -> None:",
      "        \"\"\"Create new sorted set from iterable.",
      "",
      "        Args:",
      "            a (Iterable[T]): The source for building sorted set.",
      "        \"\"\"",
      "        # Convert to list",
      "        a = list(a)",
      "        # When a is not sorted or unique, do so.",
      "        if not all(i < j for i, j in zip(a[0:-1], a[1:])):",
      "            a = sorted(a)",
      "",
      "        # Configure threshold of ratio",
      "        self.BUCKET_RATIO: int = 50",
      "        self.REBUILD_RATIO: int = 170",
      "",
      "        # Calculate and store length of sorted set.",
      "        self.size: int = len(a)",
      "        # Build the sorted set.",
      "        self._build(a)",
      "",
      "    def _build(self, a: Iterable[T] = None) -> None:",
      "        \"\"\"Evenly divide the container into buckets.",
      "",
      "        Args:",
      "            a (Iterable[T]): The source for building sorted set.",
      "        \"\"\"",
      "        # When the iterable was given, use it and override the container.",
      "        # Convert the given iterable into list.",
      "        if a is None:",
      "            a = list(self)",
      "        else:",
      "            a = list(a)",
      "",
      "        # Calculate length of the iterable.",
      "        size: int = len(a)",
      "        # Calculate each bucket size.",
      "        bucket_size: int = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
      "        # Divide the source into buckets.",
      "        self.A: list[list[T]] = [",
      "            a[size * i // bucket_size : size * (i + 1) // bucket_size]",
      "            for i in range(bucket_size)",
      "        ]",
      "",
      "    def __iter__(self) -> Iterator[T]:",
      "        for i in self.A:",
      "            for j in i:",
      "                yield j",
      "",
      "    def __reversed__(self) -> Iterator[T]:",
      "        for i in reversed(self.A):",
      "            for j in reversed(i):",
      "                yield j",
      "",
      "    def __len__(self) -> int:",
      "        return self.size",
      "",
      "    def __repr__(self) -> str:",
      "        return \"SortedSet\" + str(self.A)",
      "",
      "    def __str__(self) -> str:",
      "        s = str(list(self))",
      "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
      "",
      "    def _find_bucket(self, x: T) -> list[T]:",
      "        \"\"\"Find the bucket which should contain x.",
      "",
      "        Args:",
      "            x (T): The element of the set for search.",
      "",
      "        Return:",
      "            list[T]: The bucket which is containing x.",
      "        \"\"\"",
      "        for a in self.A:",
      "            if x <= a[-1]:",
      "                return a",
      "        return a",
      "",
      "    def __contains__(self, x: T) -> bool:",
      "        if self.size == 0:",
      "            return False",
      "",
      "        a = self._find_bucket(x)",
      "        i = bisect.bisect_left(a, x)",
      "        return i != len(a) and a[i] == x",
      "",
      "    def count(self, x: T) -> int:",
      "        \"\"\"Count the number of x.",
      "",
      "        Args:",
      "            x (T): The element of the set for count.",
      "",
      "        Returns:",
      "            int: The number of x.",
      "        \"\"\"",
      "        return self.index_right(x) - self.index(x)",
      "",
      "    def add(self, x: T) -> None:",
      "        \"\"\"Add an element into the set.",
      "",
      "        Args:",
      "            x (T): The element to add.",
      "",
      "        Return:",
      "            bool: True if the element was added, or False.",
      "        \"\"\"",
      "        # When the set is empty:",
      "        if self.size == 0:",
      "            self.A = [[x]]",
      "            self.size = 1",
      "            return",
      "",
      "        # Get the bucket in which x should be.",
      "        a = self._find_bucket(x)",
      "        # Add x into the bucket.",
      "        bisect.insort(a, x)",
      "        # Increase size of the set.",
      "        self.size += 1",
      "        # When the ratio exceed the threshold, rebuild the set",
      "        if len(a) > len(self.A) * self.REBUILD_RATIO:",
      "            self._build()",
      "",
      "    def discard(self, x: T) -> bool:",
      "        \"\"\"Remove an element from the set.",
      "",
      "        Args:",
      "            x (T): The element to remove.",
      "",
      "        Return:",
      "            bool: True if the element was successfully removed.",
      "        \"\"\"",
      "        # When the set is empty:",
      "        if self.size == 0:",
      "            return False",
      "",
      "        # Get the bucket which is containing x.",
      "        a = self._find_bucket(x)",
      "        # Get the index of x.",
      "        i = bisect.bisect_left(a, x)",
      "",
      "        # When the bucket doesn't have x:",
      "        if i == len(a) or a[i] != x:",
      "            return False",
      "",
      "        # Remove x.",
      "        a.pop(i)",
      "        # Decrease size of the set.",
      "        self.size -= 1",
      "        # If the bucket become empty, rebuild the container.",
      "        if len(a) == 0:",
      "            self._build()",
      "",
      "        return True",
      "",
      "    def lt(self, x: T) -> T | None:",
      "        \"\"\"Find the largest element less than x.",
      "",
      "        Args:",
      "            x (T): The element for search.",
      "",
      "        Return:",
      "            T: The largest element less than x.",
      "            If it doesn't exist, return None.",
      "        \"\"\"",
      "        for a in reversed(self.A):",
      "            if a[0] < x:",
      "                return a[bisect.bisect_left(a, x) - 1]",
      "        return None",
      "",
      "    def le(self, x: T) -> T | None:",
      "        \"\"\"Find the largest element less than or equal to  x.",
      "",
      "        Args:",
      "            x (T): The element for search.",
      "",
      "        Return:",
      "            T: The largest element less than or equal to  x.",
      "            If it doesn't exist, return None.",
      "        \"\"\"",
      "        for a in reversed(self.A):",
      "            if a[0] <= x:",
      "                return a[bisect.bisect_left(a, x) - 1]",
      "        return None",
      "",
      "    def gt(self, x: T) -> T | None:",
      "        \"\"\"Find the smallest element greater than x.",
      "",
      "        Args:",
      "            x (T): The element for search.",
      "",
      "        Return:",
      "            T: The smallest element greater than x.",
      "            If it doesn't exist, return None.",
      "        \"\"\"",
      "        for a in self.A:",
      "            if a[-1] > x:",
      "                return a[bisect.bisect_right(a, x)]",
      "        return None",
      "",
      "    def ge(self, x: T) -> T | None:",
      "        \"\"\"Find the smallest element greater than or equal to  x.",
      "",
      "        Args:",
      "            x (T): The element for search.",
      "",
      "        Return:",
      "            T: The smallest element greater than or equal to  x.",
      "            If it doesn't exist, return None.",
      "        \"\"\"",
      "        for a in self.A:",
      "            if a[-1] >= x:",
      "                return a[bisect.bisect_right(a, x)]",
      "",
      "        return None",
      "",
      "    def __getitem__(self, x: int) -> T:",
      "        \"\"\"Return the x-th element in the set.",
      "",
      "        Raise IndexError when it doesn't exist.",
      "",
      "        \"\"\"",
      "        if x < 0:",
      "            x += self.size",
      "",
      "        if x < 0:",
      "            raise IndexError",
      "",
      "        for a in self.A:",
      "            if x < len(a):",
      "                return a[x]",
      "            x -= len(a)",
      "        raise IndexError",
      "",
      "    def index(self, x: T) -> int:",
      "        \"\"\"Count the number of elements which is less than x.",
      "",
      "        Args:",
      "            x (T): The element fot search.",
      "",
      "        Return:",
      "            int: The number of elements which is less than x.",
      "        \"\"\"",
      "        result: int = 0",
      "        for a in self.A:",
      "            if a[-1] >= x:",
      "                return result + bisect.bisect_left(a, x)",
      "            result += len(a)",
      "",
      "        return result",
      "",
      "    def index_right(self, x: T) -> int:",
      "        \"\"\"Count the number of elements which is greater than or equal to x.",
      "",
      "        Args:",
      "            x (T): The element fot search.",
      "",
      "        Return:",
      "            int: The number of elements which is greater than or equal to x.",
      "        \"\"\"",
      "        result: int = 0",
      "        for a in self.A:",
      "            if a[-1] > x:",
      "                return result + bisect.bisect_right(a, x)",
      "            result += len(a)",
      "",
      "        return result",
      ""
    ],
    "description": "SortedMultiSet"
  },
  "VerticalVectorInput": {
    "prefix": "vlist",
    "body": "$1, $2 = map(list, zip(*[list(map(int, input().split())) for i in range($3)]))"
  },
  "RunLengthEncoding": {
    "prefix": "rle",
    "body": "$1: list[tuple[str, int]] = [(k, len(list(v))) for k, v in itertools.groupby($2)]"
  },
  "CumulativeSum2D": {
    "prefix": "CumulativeSum2D",
    "body": [
      "class CumulativeSum2D:",
      "    def __init__(self, h: int, w: int) -> None:",
      "        \"\"\"",
      "        Args:",
      "            h (int): Height of the matrix.",
      "            w (int): Width of the matrix.",
      "        \"\"\"",
      "        self.h = h",
      "        self.w = w",
      "        self.body = [[0 for i in range(w + 1)] for i in range(h + 1)]",
      "",
      "    def set(self, r: int, c: int, v: int) -> None:",
      "        \"\"\"",
      "        Set the value for the specified cell.",
      "",
      "        Args:",
      "            r (int): The index of the row for which the value will be set (1-indexed).",
      "            c (int): The index of the column for which the value will be set (1-indexed).",
      "            v (int): The value which will be set for the cell.",
      "        \"\"\"",
      "        self.body[r][c] = v",
      "",
      "    def build(self) -> None:",
      "        \"\"\"",
      "        Build cumulative sum.",
      "        \"\"\"",
      "        for i, j in itertools.product(",
      "            range(0, self.h + 1), range(0, self.w + 1)",
      "        ):",
      "            s = 0",
      "            if i > 0:",
      "                s += self.body[i - 1][j]",
      "            if j > 0:",
      "                s += self.body[i][j - 1]",
      "            if i > 0 and j > 0:",
      "                s -= self.body[i - 1][j - 1]",
      "            self.body[i][j] += s",
      "",
      "    def get(",
      "        self,",
      "        start: tuple[int, int],",
      "        end: tuple[int, int],",
      "        right_open: bool = False,",
      "    ) -> int:",
      "        \"\"\"",
      "        Get cumulative sum of the area represented by the start and end cell.",
      "",
      "        Args:",
      "            start (tuple[int, int]): The index of the start cell (1-indexed).",
      "            end (tuple[int, int]): The index of the end cell (1-indexed).",
      "            right_open (bool): If true, get right-opened cumulative sum.",
      "        \"\"\"",
      "        sr, sc = start",
      "        er, ec = end",
      "",
      "        if right_open:",
      "            result = self.body[er - 1][ec - 1]",
      "            if sr > 0:",
      "                result -= self.body[sr - 1][ec - 1]",
      "            if sc > 0:",
      "                result -= self.body[er - 1][sc - 1]",
      "            if sr > 0 and sc > 0:",
      "                result += self.body[sr - 1][sc - 1]",
      "            return result",
      "        else:",
      "            result = (",
      "                self.body[er][ec]",
      "                - self.body[sr][ec]",
      "                - self.body[er][sc]",
      "                + self.body[sr][sc]",
      "            )",
      "            return result",
      ""
    ],
    "description": "CumulativeSum2D"
  },
  "FordFulkerson": {
    "prefix": "FordFulkerson",
    "body": [
      "@dataclass",
      "class Edge:",
      "    \"\"\"",
      "    Attributes",
      "        start: The index of the node at the start of this edge.",
      "        end: The index of the node at the end of this edge.",
      "        capacity: The capacity of this edge.",
      "        rev: The inverse edge of this is the `rev`-th one that the end node of this.",
      "    \"\"\"",
      "",
      "    start: int",
      "    end: int",
      "    capacity: int",
      "    rev: int",
      "",
      "",
      "class FordFulkerson:",
      "    \"\"\"",
      "    Ford-Fulkerson method implementation",
      "",
      "    Attribute",
      "        n: The number of nodes in the graph.",
      "        m: The number of edges in the graph.",
      "        graph: Graph representation",
      "    \"\"\"",
      "",
      "    def __init__(",
      "        self,",
      "        n: int,",
      "        edges: list[tuple[int, int, int]],",
      "    ) -> None:",
      "        graph: list[list[Edge]] = [[] for _ in range(n)]",
      "        for begin, end, capacity in edges:",
      "            rev_from = len(graph[end])",
      "            rev_to = len(graph[begin])",
      "            graph[begin].append(Edge(begin, end, capacity, rev_from))",
      "            graph[end].append(Edge(end, begin, 0, rev_to))",
      "",
      "        self.n = n",
      "        self.m = len(edges)",
      "        self.graph = graph",
      "",
      "    def dfs(",
      "        self,",
      "        explored: list[bool],",
      "        current: int,",
      "        goal: int,",
      "        minimum_capacity: int,",
      "    ) -> int:",
      "        \"\"\"",
      "        Find s-t path on the current state of the graph returns the minimum capacity of the path.",
      "",
      "        Update the edge and inverse edge corresponding it during explore.",
      "",
      "        Args:",
      "            explored: The list of flags explored.",
      "            current: The index of the current node.",
      "            destination: The index of the goal node.",
      "            minimum_capacity: The minimum capacity exists on the path being explored.",
      "        \"\"\"",
      "        if current == goal:",
      "            return minimum_capacity",
      "",
      "        explored[current] = True",
      "        for e in self.graph[current]:",
      "            if explored[e.end] or e.capacity == 0:",
      "                continue",
      "",
      "            flow = self.dfs(",
      "                explored,",
      "                e.end,",
      "                goal,",
      "                min(minimum_capacity, e.capacity),",
      "            )",
      "            if flow > 0:",
      "                e.capacity -= flow",
      "                self.graph[e.end][e.rev].capacity += flow",
      "                return flow",
      "        return 0",
      "",
      "    def get_maximum_flow(self, start: int, goal: int) -> int:",
      "        \"\"\"",
      "        Find maximum flow of the graph between start and goal.",
      "        \"\"\"",
      "        maximum_flow = 0",
      "        while True:",
      "            explored = [False] * self.n",
      "",
      "            flow = self.dfs(explored, start, goal, 1 << 60)",
      "            if flow > 0:",
      "                maximum_flow += flow",
      "            else:",
      "                break",
      "",
      "        return maximum_flow",
      ""
    ],
    "description": "FordFulkerson"
  }
}
