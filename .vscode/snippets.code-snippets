{
  "Main": {
    "scope": "python",
    "description": "Starter Kit",
    "prefix": "main",
    "body": [
      "from typing import List, Tuple",
      "import sys",
      "import collections",
      "import itertools",
      "",
      "",
      "sys.setrecursionlimit(1000000)",
      "input = sys.stdin.readline",
      "",
      "",
      "def main():",
      "    $0",
      "    pass",
      "",
      "",
      "if __name__ == \"__main__\":",
      "    main()"
    ]
  },
  "Union Find": {
    "scope": "python",
    "description": "Class implementation of Union Find",
    "prefix": "UnionFind",
    "body": [
      "class UnionFind:",
      "    \"\"\"",
      "    Class implementation of disjoint-set data structure",
      "    \"\"\"",
      "",
      "    # Constructor",
      "    def __init__(self, N: int):",
      "        self._parent: List[int] = [-1 for i in range(N)]",
      "        self._rank: List[int] = [0 for i in range(N)]",
      "        self._size: List[int] = [1 for i in range(N)]",
      "",
      "    # Return the root of the tree to which x is belonging",
      "    def get_root(self, x: int) -> int:",
      "        if self._parent[x] == -1:",
      "            return x",
      "        else:",
      "            self._parent[x] = self.get_root(self._parent[x])",
      "            return self._parent[x]",
      "",
      "    # Return true if x and y belong to the same tree",
      "    def is_same(self, x: int, y: int) -> bool:",
      "        return self.get_root(x) == self.get_root(y)",
      "",
      "    # Merge the group to which x is belonging and the group to which y is belonging",
      "    def unite(self, x: int, y: int) -> bool:",
      "        # Get root of x and y",
      "        rx = self.get_root(x)",
      "        ry = self.get_root(y)",
      "",
      "        # Do nothing when x and y are already in same group",
      "        if rx == ry:",
      "            return False",
      "",
      "        # Union by rank",
      "        # Make sure that the rank of ry side is small",
      "        if self._rank[rx] < self._rank[ry]:",
      "            rx, ry = ry, rx",
      "",
      "        # Make sure that ry is child of rx",
      "        self._parent[ry] = rx",
      "",
      "        # Compute rank of rx side",
      "        if self._rank[rx] == self._rank[ry]:",
      "            self._rank[rx] += 1",
      "",
      "        # Compute size of rx side",
      "        self._size[rx] += self._size[ry]",
      "",
      "        return True",
      "",
      "    # Return size of the group to which x is belonging",
      "    def get_size(self, x: int) -> int:",
      "        return self._size[self.get_root(x)]"
    ]
  },
  "Eratosthenes Sieve": {
    "prefix": "EratosthenesSieve",
    "body": [
      "class EratosthenesSieve:",
      "    \"\"\"",
      "    Class implementation of eratosthenes sieve",
      "    \"\"\"",
      " ",
      "    def __init__(self, N: int):",
      "        \"\"\"",
      "        Constructor takes length of sieve",
      "        \"\"\"",
      "        self._N: int = N",
      "        self._is_prime: List[bool] = [True for i in range(N + 1)]",
      "        self._primes: List[int] = []",
      "        self._minimum_factor_of: List[int] = [-1 for i in range(N + 1)]",
      " ",
      "        self._is_prime[0] = self._is_prime[1] = False",
      "        self._minimum_factor_of[1] = 1",
      " ",
      "        for i in range(2, N + 1):",
      "            if not self._is_prime[i]:",
      "                continue",
      " ",
      "            self._primes.append(i)",
      "            self._minimum_factor_of[i] = i",
      " ",
      "            for j in range(2 * i, N + 1, i):",
      "                self._is_prime[j] = False",
      " ",
      "                if self._minimum_factor_of[j] == -1:",
      "                    self._minimum_factor_of[j] = i",
      " ",
      "    def factorize(self, N: int) -> List[Tuple[int, int]]:",
      "        \"\"\"",
      "        Returns a list of pair of N prime factors and their exponents.",
      "        \"\"\"",
      "        if N > self._N:",
      "            return []",
      " ",
      "        result: List[Tuple[int, int]] = []",
      "        while N > 1:",
      "            p: int = self._minimum_factor_of[N]",
      "            exp: int = 0",
      " ",
      "            while self._minimum_factor_of[N] == p:",
      "                N //= p",
      "                exp += 1",
      " ",
      "            result.append((p, exp))",
      " ",
      "        return result",
      " ",
      "    def divisors(self, N: int) -> List[int]:",
      "        \"\"\"",
      "        Returns a list of N's divisors.",
      "        \"\"\"",
      "        if N > self._N:",
      "            return []",
      " ",
      "        result: List[int] = [1]",
      "        factors: List[Tuple[int, int]] = self.factorize(N)",
      " ",
      "        for p, exp in factors:",
      "            size: int = len(factors)",
      "            for i in range(size):",
      "                v: int = 1",
      "                for j in range(exp):",
      "                    v *= p",
      "                    result.append(result[i] * v)",
      " ",
      "        return sorted(result)",
      " ",
      "    def primes(self) -> List[int]:",
      "        \"\"\"",
      "        Returns a list of prime numbers up to N.",
      "        \"\"\"",
      "        return self._primes",
      " ",
      "    def is_prime(self) -> List[bool]:",
      "        \"\"\"",
      "        Returns a list of boolean indicating whether the number is prime or not up to N.",
      "        \"\"\"",
      "        return self._is_prime"
    ],
    "description": "Eratosthenes Sieve"
  },
  "Enumerate Divisors": {
    "prefix": "divisors",
    "body": [
      "def divisors(N: int) -> List[int]:",
      "    result: List[int] = []",
      "",
      "    i: int = 1",
      "    while i * i <= N:",
      "        if N % i == 0:",
      "            result.append(i)",
      "",
      "            if N // i != i:",
      "                result.append(N // i)",
      "        i += 1",
      "",
      "    return sorted(result)"
    ],
    "description": "Enumerate Divisors"
  },
  "Prime Factorize": {
    "prefix": "factorize",
    "body": [
      "def factorize(N: int) -> List[Tuple[int, int]]:",
      "    result: List[Tuple[int, int]] = []",
      "",
      "    i: int = 2",
      "    while i * i <= N:",
      "        if N % i == 0:",
      "            exp: int = 0",
      "",
      "            while N % i == 0:",
      "                N //= i",
      "                exp += 1",
      "",
      "            result.append((i, exp))",
      "        i += 1",
      "",
      "    if N != 1:",
      "        result.append((N, 1))",
      "",
      "    return result"
    ],
    "description": "Prime Factorize"
  },
  "Input a number": {
    "prefix": "anumber",
    "body": ["$0: int = int(input())"],
    "description": "Input one number via standard input"
  },
  "Input some numbers": {
    "prefix": "somenumber",
    "body": "$1, $0 = map(int, input().split())",
    "description": "Input some numbers"
  },
  "Input 1D Vector": {
    "prefix": "alist",
    "body": "$0: List[int] = list(map(int, input().split()))",
    "description": "Input 1D vector which contains integer as element"
  },
  "Input a string": {
    "prefix": "astring",
    "body": ["$1: str = input().rstrip()"],
    "description": "Input one string via standard input"
  },
  "BinominalCoefficient": {
    "prefix": "binominal_coefficient",
    "body": [
      "class BinominalCoefficient:",
      "    def __init__(self, N: int, mod: int):",
      "        self._N: int = N",
      "        self._mod: int = mod",
      "        self._factorial: List[int] = [1 for i in range(N + 1)]",
      "        self._inverse_element: List[int] = [1 for i in range(N + 1)]",
      "        self._inverse_factorial: List[int] = [1 for i in range(N + 1)]",
      "",
      "        for i in range(2, self._N + 1):",
      "            self._factorial[i] = self._factorial[i - 1] * i % self._mod",
      "            self._inverse_element[i] = (",
      "                self._mod",
      "                - self._inverse_element[self._mod % i] * (self._mod // i) % self._mod",
      "            )",
      "            self._inverse_factorial[i] = (",
      "                self._inverse_factorial[i - 1] * self._inverse_element[i] % self._mod",
      "            )",
      "",
      "    def nCr(self, n: int, r: int) -> int:",
      "        if n > self._N or n < r or n < 0 or r < 0:",
      "            return 0",
      "",
      "        return (",
      "            self._factorial[n]",
      "            * (self._inverse_factorial[r] * self._inverse_factorial[n - r] % self._mod)",
      "            % self._mod",
      "        )"
    ],
    "description": "BinominalCoefficient"
  },
  "mod1000000007": {
    "prefix": "mod1000000007",
    "body": "mod: int = 1000000007",
    "description": "modulo for competitive programing"
  }
}
