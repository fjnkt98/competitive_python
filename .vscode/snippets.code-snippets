{
  "Main": {
    "scope": "python",
    "description": "Starter Kit",
    "prefix": "main",
    "body": [
      "from typing import List, Tuple, Deque, Set, Dict, TypeVar, Callable, Generic",
      "import sys",
      "import collections",
      "import itertools",
      "",
      "",
      "sys.setrecursionlimit(1000000)",
      "input = sys.stdin.readline",
      "",
      "",
      "def main():",
      "    $0",
      "    pass",
      "",
      "",
      "if __name__ == \"__main__\":",
      "    main()"
    ]
  },
  "Union Find": {
    "scope": "python",
    "description": "Class implementation of Union Find",
    "prefix": "UnionFind",
    "body": [
      "class UnionFind:",
      "    \"\"\"",
      "    Class implementation of disjoint-set data structure",
      "    \"\"\"",
      "",
      "    # Constructor",
      "    def __init__(self, N: int):",
      "        self._parent: List[int] = [-1 for i in range(N)]",
      "        self._rank: List[int] = [0 for i in range(N)]",
      "        self._size: List[int] = [1 for i in range(N)]",
      "",
      "    # Return the root of the tree to which x is belonging",
      "    def get_root(self, x: int) -> int:",
      "        if self._parent[x] == -1:",
      "            return x",
      "        else:",
      "            self._parent[x] = self.get_root(self._parent[x])",
      "            return self._parent[x]",
      "",
      "    # Return true if x and y belong to the same tree",
      "    def is_same(self, x: int, y: int) -> bool:",
      "        return self.get_root(x) == self.get_root(y)",
      "",
      "    # Merge the group to which x is belonging and the group to which y is belonging",
      "    def unite(self, x: int, y: int) -> bool:",
      "        # Get root of x and y",
      "        rx = self.get_root(x)",
      "        ry = self.get_root(y)",
      "",
      "        # Do nothing when x and y are already in same group",
      "        if rx == ry:",
      "            return False",
      "",
      "        # Union by rank",
      "        # Make sure that the rank of ry side is small",
      "        if self._rank[rx] < self._rank[ry]:",
      "            rx, ry = ry, rx",
      "",
      "        # Make sure that ry is child of rx",
      "        self._parent[ry] = rx",
      "",
      "        # Compute rank of rx side",
      "        if self._rank[rx] == self._rank[ry]:",
      "            self._rank[rx] += 1",
      "",
      "        # Compute size of rx side",
      "        self._size[rx] += self._size[ry]",
      "",
      "        return True",
      "",
      "    # Return size of the group to which x is belonging",
      "    def get_size(self, x: int) -> int:",
      "        return self._size[self.get_root(x)]"
    ]
  },
  "Eratosthenes Sieve": {
    "prefix": "EratosthenesSieve",
    "body": [
      "class EratosthenesSieve:",
      "    \"\"\"",
      "    Class implementation of eratosthenes sieve",
      "    \"\"\"",
      " ",
      "    def __init__(self, N: int):",
      "        \"\"\"",
      "        Constructor takes length of sieve",
      "        \"\"\"",
      "        self._N: int = N",
      "        self._is_prime: List[bool] = [True for i in range(N + 1)]",
      "        self._primes: List[int] = []",
      "        self._minimum_factor_of: List[int] = [-1 for i in range(N + 1)]",
      " ",
      "        self._is_prime[0] = self._is_prime[1] = False",
      "        self._minimum_factor_of[1] = 1",
      " ",
      "        for i in range(2, N + 1):",
      "            if not self._is_prime[i]:",
      "                continue",
      " ",
      "            self._primes.append(i)",
      "            self._minimum_factor_of[i] = i",
      " ",
      "            for j in range(2 * i, N + 1, i):",
      "                self._is_prime[j] = False",
      " ",
      "                if self._minimum_factor_of[j] == -1:",
      "                    self._minimum_factor_of[j] = i",
      " ",
      "    def factorize(self, N: int) -> List[Tuple[int, int]]:",
      "        \"\"\"",
      "        Returns a list of pair of N prime factors and their exponents.",
      "        \"\"\"",
      "        if N > self._N:",
      "            return []",
      " ",
      "        result: List[Tuple[int, int]] = []",
      "        while N > 1:",
      "            p: int = self._minimum_factor_of[N]",
      "            exp: int = 0",
      " ",
      "            while self._minimum_factor_of[N] == p:",
      "                N //= p",
      "                exp += 1",
      " ",
      "            result.append((p, exp))",
      " ",
      "        return result",
      " ",
      "    def divisors(self, N: int) -> List[int]:",
      "        \"\"\"",
      "        Returns a list of N's divisors.",
      "        \"\"\"",
      "        if N > self._N:",
      "            return []",
      " ",
      "        result: List[int] = [1]",
      "        factors: List[Tuple[int, int]] = self.factorize(N)",
      " ",
      "        for p, exp in factors:",
      "            size: int = len(result)",
      "            for i in range(size):",
      "                v: int = 1",
      "                for j in range(exp):",
      "                    v *= p",
      "                    result.append(result[i] * v)",
      " ",
      "        return sorted(result)",
      " ",
      "    def primes(self) -> List[int]:",
      "        \"\"\"",
      "        Returns a list of prime numbers up to N.",
      "        \"\"\"",
      "        return self._primes",
      " ",
      "    def is_prime(self) -> List[bool]:",
      "        \"\"\"",
      "        Returns a list of boolean indicating whether the number is prime or not up to N.",
      "        \"\"\"",
      "        return self._is_prime"
    ],
    "description": "Eratosthenes Sieve"
  },
  "Enumerate Divisors": {
    "prefix": "divisors",
    "body": [
      "def divisors(N: int) -> List[int]:",
      "    result: List[int] = []",
      "",
      "    i: int = 1",
      "    while i * i <= N:",
      "        if N % i == 0:",
      "            result.append(i)",
      "",
      "            if N // i != i:",
      "                result.append(N // i)",
      "        i += 1",
      "",
      "    return sorted(result)"
    ],
    "description": "Enumerate Divisors"
  },
  "Prime Factorize": {
    "prefix": "factorize",
    "body": [
      "def factorize(N: int) -> List[Tuple[int, int]]:",
      "    result: List[Tuple[int, int]] = []",
      "",
      "    i: int = 2",
      "    while i * i <= N:",
      "        if N % i == 0:",
      "            exp: int = 0",
      "",
      "            while N % i == 0:",
      "                N //= i",
      "                exp += 1",
      "",
      "            result.append((i, exp))",
      "        i += 1",
      "",
      "    if N != 1:",
      "        result.append((N, 1))",
      "",
      "    return result"
    ],
    "description": "Prime Factorize"
  },
  "Input a number": {
    "prefix": "anumber",
    "body": ["$0: int = int(input())"],
    "description": "Input one number via standard input"
  },
  "Input some numbers": {
    "prefix": "somenumber",
    "body": "$1, $0 = map(int, input().split())",
    "description": "Input some numbers"
  },
  "Input 1D Vector": {
    "prefix": "alist",
    "body": "$0: List[int] = list(map(int, input().split()))",
    "description": "Input 1D vector which contains integer as element"
  },
  "Input vector of vector": {
    "prefix": "listlist",
    "body": "$1: List[List[int]] = [list(map(int, input().split())) for i in range($0)]",
    "description": "Input 1D vector which contains 1D vector of integer"
  },
  "Input a string": {
    "prefix": "astring",
    "body": ["$1: str = input().rstrip()"],
    "description": "Input one string via standard input"
  },
  "BinominalCoefficient": {
    "prefix": "binominal_coefficient",
    "body": [
      "class BinominalCoefficient:",
      "    def __init__(self, N: int, mod: int):",
      "        self._N: int = N",
      "        self._mod: int = mod",
      "        self._factorial: List[int] = [1 for i in range(N + 1)]",
      "        self._inverse_element: List[int] = [1 for i in range(N + 1)]",
      "        self._inverse_factorial: List[int] = [1 for i in range(N + 1)]",
      "",
      "        for i in range(2, self._N + 1):",
      "            self._factorial[i] = self._factorial[i - 1] * i % self._mod",
      "            self._inverse_element[i] = (",
      "                self._mod",
      "                - self._inverse_element[self._mod % i] * (self._mod // i) % self._mod",
      "            )",
      "            self._inverse_factorial[i] = (",
      "                self._inverse_factorial[i - 1] * self._inverse_element[i] % self._mod",
      "            )",
      "",
      "    def nCr(self, n: int, r: int) -> int:",
      "        if n > self._N or n < r or n < 0 or r < 0:",
      "            return 0",
      "",
      "        return (",
      "            self._factorial[n]",
      "            * (self._inverse_factorial[r] * self._inverse_factorial[n - r] % self._mod)",
      "            % self._mod",
      "        )"
    ],
    "description": "BinominalCoefficient"
  },
  "mod1000000007": {
    "prefix": "mod1000000007",
    "body": "mod: int = 1000000007",
    "description": "modulo for competitive programing"
  },
  "mod998244353": {
    "prefix": "mod998244353",
    "body": "mod: int = 998244353",
    "description": "modulo for competitive programing"
  },
  "Lazy segment tree": {
    "prefix": "LazySegmentTree",
    "body": [
      "# Type of the element of segment tree",
      "S = TypeVar(\"S\")",
      "# Type of the operator",
      "F = TypeVar(\"F\")",
      "",
      "",
      "class LazySegmentTree(Generic[S, F]):",
      "    \"\"\"Segment Tree with Lazy Propagation",
      "",
      "    Non-recursive, and abstracted lazy segment tree implementation.",
      "",
      "    Attributes:",
      "        -N (int): Number of the elements managed by segment tree.",
      "        _op (Callable[[S, S], S]): A function object representing the binary operator.",
      "        _e (Callable[[], int]): A function object which returns identity element.",
      "        _mapping (Callable[[F, S], S]): A function object representing the mapping.",
      "                                        mapping() takes the operator f and target",
      "                                        element s,",
      "                                        and returns the result.",
      "        _composition (Callable[[F, F], F]): A function object representing the",
      "                                            composition of maps.",
      "                                            composition() takes two operator, and",
      "                                            returns composited operator.",
      "        _id (Callable[[], F]): A function object representing identity mapping.",
      "        _log (int): The logarithm of size of segment tree base 2.",
      "        _size (int): Size of the list that representing binary tree object.",
      "        _data (List[S]): A list of the entities representing segment tree.(1-indexed)",
      "        _lazy (List[F]): A list for lazy propagation. lazy[k] holds the operation",
      "                         performed in the segment corresponding to the data[k] which",
      "                         haven't yet been applied to the nodes below the data[k].",
      "",
      "    \"\"\"",
      "",
      "    def __init__(",
      "        self,",
      "        op: Callable[[S, S], S],",
      "        e: Callable[[], S],",
      "        mapping: Callable[[F, S], S],",
      "        composition: Callable[[F, F], F],",
      "        id: Callable[[], F],",
      "        A: List[S],",
      "    ):",
      "        \"\"\"Constructor",
      "",
      "        Construct segment tree",
      "",
      "        Args:",
      "            op (Callable[[S, S], S])",
      "            e (Callable[[], S])",
      "            mapping (Callable[[F, S], S])",
      "            composition (Callable[[F, F], F])",
      "            id (Callable[[], F])",
      "            A (List[S])",
      "",
      "        \"\"\"",
      "",
      "        self._N: int = len(A)",
      "        self._op: Callable[[S, S], S] = op",
      "        self._e: Callable[[], S] = e",
      "        self._mapping: Callable[[F, S], S] = mapping",
      "        self._composition: Callable[[F, F], F] = composition",
      "        self._id: Callable[[], F] = id",
      "        self._log: int = (self._N - 1).bit_length()",
      "        self._size: int = 1 << self._log",
      "        # Initialize each element of the list with identity element.",
      "        self._data: List[S] = [self._e()] * (2 * self._size)",
      "        self._lazy: List[F] = [self._id()] * self._size",
      "",
      "        # Initialize leaves with given list A.",
      "        self._data[self._size : self._size + self._N] = A",
      "",
      "        # Update all nodes (not leaf).",
      "        for i in range(self._size - 1, 0, -1):",
      "            self._update(i)",
      "",
      "    def set(self, k: int, x: S) -> None:",
      "        \"\"\"Set x into the specified leaf.",
      "",
      "        Args:",
      "            k (int): The index of the leaf(0-indexed).",
      "",
      "        \"\"\"",
      "",
      "        # Move to the leaf.",
      "        k += self._size",
      "",
      "        # Propagate pending operator from the root to the leaf.",
      "        for i in range(self._log, 0, -1):",
      "            self._propagate(k >> i)",
      "",
      "        # Update value of the element from the leaf to the root.",
      "        for i in range(1, self._log + 1):",
      "            self._update(k >> i)",
      "",
      "    def get(self, k: int) -> S:",
      "        \"\"\"Get the value of the specified leaf.",
      "",
      "        Args:",
      "            k (int): The index of the leaf(0-indexed).",
      "",
      "        Returns:",
      "            S: Value of the specified leaf.",
      "",
      "        \"\"\"",
      "",
      "        # Move to the leaf.",
      "        k += self._size",
      "",
      "        # Propagate pending operator from the root to the leaf.",
      "        for i in range(self._log, 0, -1):",
      "            self._propagate(k >> i)",
      "",
      "        # Return the value.",
      "        return self._data[k]",
      "",
      "    def prod(self, l: int, r: int) -> S:",
      "        \"\"\"Returns op(A[l], ..., A[r - 1]).",
      "",
      "        Returns the result of applying the binary operator to the interval [l, r).",
      "",
      "        Args:",
      "            l (int): Left end of the given interval.",
      "            r (int): Right end of the given interval. it doesn't not include",
      "                     the right end.",
      "",
      "        Returns:",
      "            S: The result.",
      "",
      "        \"\"\"",
      "",
      "        # When invalid interval was given",
      "        if l >= r:",
      "            return self._e()",
      "",
      "        # Move to leaf",
      "        l += self._size",
      "        r += self._size",
      "",
      "        # Variable to hold the left result",
      "        left_result: S = self._e()",
      "        # Variable to hold the right result",
      "        right_result: S = self._e()",
      "",
      "        # Propagate pending operator from the root to the leaf",
      "        # for calculate the production",
      "        for i in range(self._log, 0, -1):",
      "            # In the subtree containing the l, when the l is the leftmost node,",
      "            # don't have to propagate. Because the root of the subtree has all",
      "            # information of l.",
      "            if ((l >> i) << i) != l:",
      "                self._propagate(l >> i)",
      "            # Same to above.",
      "            if ((r >> i) << i) != r:",
      "                self._propagate((r - 1) >> i)",
      "",
      "        # Find all nodes covering the given interval.",
      "        while l < r:",
      "            # If l is right child",
      "            if l & 1:",
      "                # Calculate result.",
      "                left_result = self._op(left_result, self._data[l])",
      "                # Move to elder brother.",
      "                l += 1",
      "",
      "            # If r is right child",
      "            if r & 1:",
      "                # Move to little brother.",
      "                r -= 1",
      "                # Calculate result.",
      "                right_result = self._op(right_result, self._data[r])",
      "",
      "            # Move to parent.",
      "            l >>= 1",
      "            r >>= 1",
      "",
      "        # Return the result.",
      "        return self._op(left_result, right_result)",
      "",
      "    def prod_all(self) -> S:",
      "        \"\"\"Returns op(A[0], ..., A[N - 1]).",
      "",
      "        Return the result of applying the binary operator to all monoids.",
      "",
      "        Returns:",
      "            S: The operation result.",
      "",
      "        \"\"\"",
      "        return self._data[1]",
      "",
      "    def apply(self, k: int, f: F) -> None:",
      "        \"\"\"Apply the mapping to single leaf.",
      "",
      "        Apply the mapping to the single leaf with specified index.",
      "",
      "        Args:",
      "            k (int): Index of the leaf(0-indexed).",
      "            f (F): The value to be acted on the leaf.",
      "",
      "        \"\"\"",
      "",
      "        # Move to leaf.",
      "        k += self._size",
      "",
      "        # Propagate pending operator from the root to the leaf.",
      "        for i in range(self._log, 0, -1):",
      "            self._propagate(k >> i)",
      "",
      "        # Apply the mapping to the leaf.",
      "        self._data[k] = self._mapping(f, self._data[k])",
      "",
      "        # Update ancestors.",
      "        for i in range(1, self._log + 1):",
      "            self._update(k >> i)",
      "",
      "    def apply_each(self, l: int, r: int, f: F) -> None:",
      "        \"\"\"Apply the mapping to each leaves of the specified interval.",
      "",
      "        Apply the mapping to each leaves of the specified interval [l, r).",
      "",
      "        Args:",
      "            l (int): Left end of the given interval.",
      "            r (int): Right end of the given interval.",
      "            f (F): The value to be acted on the leaves.",
      "",
      "        \"\"\"",
      "",
      "        # When invalid interval was given",
      "        if l >= r:",
      "            return",
      "",
      "        # Move to leaf.",
      "        l += self._size",
      "        r += self._size",
      "",
      "        # Propagate pending operator from the root to the leaf",
      "        # for calculate the production",
      "        for i in range(self._log, 0, -1):",
      "            # In the subtree containing the l, when the l is the leftmost node,",
      "            # don't have to propagate. Because the root of the subtree has all",
      "            # information of l.",
      "            if ((l >> i) << i) != l:",
      "                self._propagate(l >> i)",
      "            # Same to above.",
      "            if ((r >> i) << i) != r:",
      "                self._propagate((r - 1) >> i)",
      "",
      "        # Copy the variable for temporary calculation.",
      "        left: int = l",
      "        right: int = r",
      "        # Find all nodes covering the given interval, and apply the mapping to them.",
      "        while left < right:",
      "            # If left is right child",
      "            if left & 1:",
      "                # Apply the mapping.",
      "                self._reflect(left, f)",
      "                # Move to elder brother.",
      "                left += 1",
      "",
      "            # If right is right child",
      "            if right & 1:",
      "                # Move to little brother.",
      "                right -= 1",
      "                # Apply the mapping.",
      "                self._reflect(right, f)",
      "",
      "            # Move to parent.",
      "            left >>= 1",
      "            right >>= 1",
      "",
      "        # Update value of the ancestors.",
      "        for i in range(1, self._log + 1):",
      "            # In the subtree containing the l, when the l is the leftmost node,",
      "            # don't have to update. Because the root of the subtree has all",
      "            # information of l.",
      "            if ((l >> i) << i) != l:",
      "                self._update(l >> i)",
      "            # Same to above.",
      "            if ((r >> i) << i) != r:",
      "                self._update(r >> i)",
      "",
      "    def _reflect(self, k: int, f: F) -> None:",
      "        \"\"\"Recleft the operation on the node.",
      "",
      "        Reflect the specified operator f on the node data[k], and if the node is leaf,",
      "        combine the operator f with lazy[k].",
      "",
      "        Args:",
      "            k (int): The index of the node (0-indexed).",
      "            f (F): The operator.",
      "",
      "        \"\"\"",
      "",
      "        # Reflect the operator on the node.",
      "        self._data[k] = self._mapping(f, self._data[k])",
      "",
      "        # When k is not leaf",
      "        if k < self._size:",
      "            # Combine the operator f with lazy[k]",
      "            self._lazy[k] = self._composition(f, self._lazy[k])",
      "",
      "    def _propagate(self, k: int) -> None:",
      "        \"\"\"Propagate pending operator to each child.",
      "",
      "        Propagate pending operator lazy[k] to each child, and reset lazy[k].",
      "",
      "",
      "        Args:",
      "            k (int): The index of the node (0-indexed).",
      "",
      "        \"\"\"",
      "",
      "        # Propagate operator lazy[k] to left child.",
      "        self._reflect(2 * k, self._lazy[k])",
      "        # Propagate operator lazy[k] to right child.",
      "        self._reflect(2 * k + 1, self._lazy[k])",
      "",
      "        # Reset lazy[k]",
      "        self._lazy[k] = self._id()",
      "",
      "    def _update(self, k: int) -> None:",
      "        \"\"\"Update the element.",
      "",
      "        Update value of the element with the value of the child node.",
      "",
      "        Args:",
      "            k (int): The index of the node (0-indexed).",
      "",
      "        \"\"\"",
      "        self._data[k] = self._op(self._data[2 * k], self._data[2 * k + 1])"
    ],
    "description": "Lazy segment tree"
  },
  "Segment Tree": {
    "prefix": "SegmentTree",
    "body": [
      "# Type of the element of segment tree",
      "S = TypeVar(\"S\")",
      "",
      "",
      "class SegmentTree(Generic[S]):",
      "    \"\"\"Segment Tree",
      "",
      "    Non-recursive, and abstracted segment tree implementation.",
      "",
      "    Attributes:",
      "        -N (int): Number of the elements managed by segment tree.",
      "        _op (Callable[[S, S], S]): A function object representing the binary operator.",
      "        _e (Callable[[], int]): A function object which returns identity element.",
      "        _log (int): The logarithm of size of segment tree base 2.",
      "        _size (int): Size of the list that representing binary tree object.",
      "        _data (List[S]): A list of the entities representing segment tree.(1-indexed)",
      "",
      "    \"\"\"",
      "",
      "    def __init__(self, op: Callable[[S, S], S], e: Callable[[], S], A: List[S]):",
      "        self._N = len(A)",
      "        self._op = op",
      "        self._e = e",
      "        self._log: int = (self._N - 1).bit_length()",
      "        self._size: int = 1 << self._log",
      "        self._data: List[S] = [self._e()] * (2 * self._size)",
      "",
      "        # Initialize leaves with given list A.",
      "        self._data[self._size : self._size + self._N] = A",
      "",
      "        # Update all nodes (not leaf).",
      "        for i in range(self._size - 1, 0, -1):",
      "            self._update(i)",
      "",
      "    def get(self, k: int) -> S:",
      "        \"\"\"Get the value of the specified leaf.",
      "",
      "        Args:",
      "            k (int): The index of the leaf(0-indexed).",
      "",
      "        Returns:",
      "            S: Value of the specified leaf.",
      "",
      "        \"\"\"",
      "",
      "        return self._data[k + self._size]",
      "",
      "    def set(self, k: int, x: S) -> None:",
      "        \"\"\"Set x into the specified leaf.",
      "",
      "        Args:",
      "            k (int): The index of the leaf(0-indexed).",
      "            x (S): The value to apply.",
      "",
      "        \"\"\"",
      "",
      "        # Move to the leaf.",
      "        k += self._size",
      "",
      "        # Set the value of the leaf",
      "        self._data[k] = x",
      "",
      "        # Update value of the element from the leaf to the root.",
      "        for i in range(1, self._log + 1):",
      "            self._update(k >> i)",
      "",
      "    def prod(self, l: int, r: int) -> S:",
      "        \"\"\"Returns op(A[l], ..., A[r - 1]).",
      "",
      "        Returns the result of applying the binary operator to the interval [l, r).",
      "",
      "        Args:",
      "            l (int): Left end of the given interval.",
      "            r (int): Right end of the given interval. it doesn't include",
      "                     the right end.",
      "",
      "        Returns:",
      "            S: The result.",
      "",
      "        \"\"\"",
      "",
      "        # When invalid interval was given",
      "        if l >= r:",
      "            return self._e()",
      "",
      "        # Move to leaf",
      "        l += self._size",
      "        r += self._size",
      "",
      "        # Variable to hold the left result",
      "        left_result: S = self._e()",
      "        # Variable to hold the right result",
      "        right_result: S = self._e()",
      "",
      "        # Find all nodes covering the given interval.",
      "        while l < r:",
      "            # If l is right child",
      "            if l & 1:",
      "                # Calculate result.",
      "                left_result = self._op(left_result, self._data[l])",
      "                # Move to elder brother.",
      "                l += 1",
      "",
      "            # If r is right child",
      "            if r & 1:",
      "                # Move to little brother.",
      "                r -= 1",
      "                # Calculate result.",
      "                right_result = self._op(right_result, self._data[r])",
      "",
      "            # Move to parent.",
      "            l >>= 1",
      "            r >>= 1",
      "",
      "        # Return the result.",
      "        return self._op(left_result, right_result)",
      "",
      "    def prod_all(self) -> S:",
      "        \"\"\"Returns op(A[0], ..., A[N - 1]).",
      "",
      "        Return the result of applying the binary operator to all monoids.",
      "",
      "        Returns:",
      "            S: The operation result.",
      "",
      "        \"\"\"",
      "        return self._data[1]",
      "",
      "    def _update(self, k: int) -> None:",
      "        \"\"\"Update the element.",
      "",
      "        Update value of the element with the value of the child node.",
      "",
      "        Args:",
      "            k (int): The index of the node (0-indexed).",
      "",
      "        \"\"\"",
      "        self._data[k] = self._op(self._data[2 * k], self._data[2 * k + 1])"
    ],
    "description": "Segment Tree"
  },
  "WeightedUnionFindTree": {
    "prefix": "WeightedUnionFind",
    "body": [
      "# Type of the weight for Weighted Union-Find Tree",
      "T = TypeVar(\"T\", int, float)",
      "",
      "",
      "class WeightedUnionFind(Generic[T]):",
      "    \"\"\"Weighted Union-Find Tree",
      "",
      "    Weighted Union-Find Tree imple\"WeightedUnionFindTree\": {",
      "  \"prefix\": \"WeightedUnionFind\",",
      "  \"body\": [",
      "    \"# Type of the weight for Weighted Union-Find Tree\",",
      "    \"T = TypeVar(\\\"T\\\", int, float)\",",
      "    \"\",",
      "    \"\",",
      "    \"class WeightedUnionFind(Generic[T]):\",",
      "    \"    \\\"\\\"\\\"Weighted Union-Find Tree\",",
      "    \"\",",
      "    \"    Weighted Union-Find Tree implementation.\",",
      "    \"\",",
      "    \"    Attributes:\",",
      "    \"        _N (int): Number of nodes.\",",
      "    \"        _e (T): Identity element of the abelian group. Normally assigned 0.\",",
      "    \"        _parent (List[int]): List retaining the parent node of the node.\",",
      "    \"        _rank (List[int]): List retaining the rank of the node.\",",
      "    \"        _diff_weight (List[T]): List retaining the weight difference\",",
      "    \"                                between the root of the subtree.\",",
      "    \"\",",
      "    \"    \\\"\\\"\\\"\",",
      "    \"\",",
      "    \"    def __init__(self, N: int, e: T):\",",
      "    \"        \\\"\\\"\\\"Constructor\",",
      "    \"\",",
      "    \"        Args:\",",
      "    \"            N (int): Number of nodes.\",",
      "    \"            e (T): Identity element of the abelian group. Normally assigned 0.\",",
      "    \"\",",
      "    \"        \\\"\\\"\\\"\",",
      "    \"        self._N: int = N\",",
      "    \"        self._e: T = e\",",
      "    \"        self._parent: List[int] = [i for i in range(N)]\",",
      "    \"        self._rank: List[int] = [0 for i in range(N)]\",",
      "    \"        self._diff_weight: List[T] = [e for i in range(N)]\",",
      "    \"\",",
      "    \"    def root(self, v: int) -> int:\",",
      "    \"        \\\"\\\"\\\"Returns the root.\",",
      "    \"\",",
      "    \"        Returns the root of the subtree to which the node v is belonging.\",",
      "    \"        In addition, route-compression is also performed.\",",
      "    \"\",",
      "    \"        Args:\",",
      "    \"            v (int): The index of the specified node.\",",
      "    \"\",",
      "    \"        Returns:\",",
      "    \"            int: The index of the root.\",",
      "    \"\",",
      "    \"        \\\"\\\"\\\"\",",
      "    \"\",",
      "    \"        # Return itself if node v is the root.\",",
      "    \"        if self._parent[v] == v:\",",
      "    \"            return v\",",
      "    \"\",",
      "    \"        # Get the root recursively.\",",
      "    \"        r: int = self.root(self._parent[v])\",",
      "    \"        # Accumulate weight.\",",
      "    \"        self._diff_weight[v] += self._diff_weight[self._parent[v]]\",",
      "    \"        # Update the list.\",",
      "    \"        self._parent[v] = r\",",
      "    \"\",",
      "    \"        # Return the root.\",",
      "    \"        return r\",",
      "    \"\",",
      "    \"    def weight(self, v: int) -> T:\",",
      "    \"        \\\"\\\"\\\"Returns the weight of the node.\",",
      "    \"\",",
      "    \"        Returns the weight difference between the root and the node.\",",
      "    \"\",",
      "    \"        Args:\",",
      "    \"            v (int): The index of the node.\",",
      "    \"\",",
      "    \"        \\\"\\\"\\\"\",",
      "    \"        # Conduct route-compression.\",",
      "    \"        self.root(v)\",",
      "    \"\",",
      "    \"        # Return the difference of weight.\",",
      "    \"        return self._diff_weight[v]\",",
      "    \"\",",
      "    \"    def is_same(self, x: int, y: int) -> bool:\",",
      "    \"        \\\"\\\"\\\"Determine if they are in same group.\",",
      "    \"\",",
      "    \"        Determine if they are in same group.\",",
      "    \"\",",
      "    \"        Args:\",",
      "    \"            x (int): The index of the node.\",",
      "    \"            y (int): The index of the other node.\",",
      "    \"\",",
      "    \"        Returns:\",",
      "    \"            bool: True if x and y are belonging same group. Otherwise, False.\",",
      "    \"\",",
      "    \"        \\\"\\\"\\\"\",",
      "    \"        return self.root(x) == self.root(y)\",",
      "    \"\",",
      "    \"    def unite(self, x: int, y: int, w: T) -> bool:\",",
      "    \"        \\\"\\\"\\\"Merge two nodes.\",",
      "    \"\",",
      "    \"        Merge specified two nodes.\",",
      "    \"\",",
      "    \"        Args:\",",
      "    \"            x (int): The index of the node.\",",
      "    \"            y (int): The index of the other node.\",",
      "    \"            w (T): The weight difference between x and y.\",",
      "    \"\",",
      "    \"        Returns:\",",
      "    \"            bool: False if x and y are already in same group.\",",
      "    \"\",",
      "    \"        \\\"\\\"\\\"\",",
      "    \"\",",
      "    \"        # Compensate the weight because each root is merged in fact.\",",
      "    \"        w += self.weight(x)\",",
      "    \"        w -= self.weight(y)\",",
      "    \"\",",
      "    \"        # Move to each root.\",",
      "    \"        x = self.root(x)\",",
      "    \"        y = self.root(y)\",",
      "    \"\",",
      "    \"        # Return false if x and y are already in same group.\",",
      "    \"        if x == y:\",",
      "    \"            return False\",",
      "    \"\",",
      "    \"        # Swap so that the rank of x is higher.\",",
      "    \"        if self._rank[x] < self._rank[y]:\",",
      "    \"            x, y = y, x\",",
      "    \"            w = -w\",",
      "    \"\",",
      "    \"        # If the two trees are the same rank, the rank increases by 1 after merge.\",",
      "    \"        if self._rank[x] == self._rank[y]:\",",
      "    \"            self._rank[x] += 1\",",
      "    \"\",",
      "    \"        # Update parent.\",",
      "    \"        self._parent[y] = x\",",
      "    \"\",",
      "    \"        # Update weight.\",",
      "    \"        self._diff_weight[y] = w\",",
      "    \"\",",
      "    \"        # Successfully merged.\",",
      "    \"        return True\",",
      "    \"\",",
      "    \"    def diff(self, x: int, y: int) -> T:\",",
      "    \"        return self.weight(y) - self.weight(x)\"",
      "  ],",
      "  \"description\": \"WeightedUnionFindTree\"",
      "}mentation.",
      "",
      "    Attributes:",
      "        _N (int): Number of nodes.",
      "        _e (T): Identity element of the abelian group. Normally assigned 0.",
      "        _parent (List[int]): List retaining the parent node of the node.",
      "        _rank (List[int]): List retaining the rank of the node.",
      "        _diff_weight (List[T]): List retaining the weight difference",
      "                                between the root of the subtree.",
      "",
      "    \"\"\"",
      "",
      "    def __init__(self, N: int, e: T):",
      "        \"\"\"Constructor",
      "",
      "        Args:",
      "            N (int): Number of nodes.",
      "            e (T): Identity element of the abelian group. Normally assigned 0.",
      "",
      "        \"\"\"",
      "        self._N: int = N",
      "        self._e: T = e",
      "        self._parent: List[int] = [i for i in range(N)]",
      "        self._rank: List[int] = [0 for i in range(N)]",
      "        self._diff_weight: List[T] = [e for i in range(N)]",
      "",
      "    def root(self, v: int) -> int:",
      "        \"\"\"Returns the root.",
      "",
      "        Returns the root of the subtree to which the node v is belonging.",
      "        In addition, route-compression is also performed.",
      "",
      "        Args:",
      "            v (int): The index of the specified node.",
      "",
      "        Returns:",
      "            int: The index of the root.",
      "",
      "        \"\"\"",
      "",
      "        # Return itself if node v is the root.",
      "        if self._parent[v] == v:",
      "            return v",
      "",
      "        # Get the root recursively.",
      "        r: int = self.root(self._parent[v])",
      "        # Accumulate weight.",
      "        self._diff_weight[v] += self._diff_weight[self._parent[v]]",
      "        # Update the list.",
      "        self._parent[v] = r",
      "",
      "        # Return the root.",
      "        return r",
      "",
      "    def weight(self, v: int) -> T:",
      "        \"\"\"Returns the weight of the node.",
      "",
      "        Returns the weight difference between the root and the node.",
      "",
      "        Args:",
      "            v (int): The index of the node.",
      "",
      "        \"\"\"",
      "        # Conduct route-compression.",
      "        self.root(v)",
      "",
      "        # Return the difference of weight.",
      "        return self._diff_weight[v]",
      "",
      "    def is_same(self, x: int, y: int) -> bool:",
      "        \"\"\"Determine if they are in same group.",
      "",
      "        Determine if they are in same group.",
      "",
      "        Args:",
      "            x (int): The index of the node.",
      "            y (int): The index of the other node.",
      "",
      "        Returns:",
      "            bool: True if x and y are belonging same group. Otherwise, False.",
      "",
      "        \"\"\"",
      "        return self.root(x) == self.root(y)",
      "",
      "    def unite(self, x: int, y: int, w: T) -> bool:",
      "        \"\"\"Merge two nodes.",
      "",
      "        Merge specified two nodes.",
      "",
      "        Args:",
      "            x (int): The index of the node.",
      "            y (int): The index of the other node.",
      "            w (T): The weight difference between x and y.",
      "",
      "        Returns:",
      "            bool: False if x and y are already in same group.",
      "",
      "        \"\"\"",
      "",
      "        # Compensate the weight because each root is merged in fact.",
      "        w += self.weight(x)",
      "        w -= self.weight(y)",
      "",
      "        # Move to each root.",
      "        x = self.root(x)",
      "        y = self.root(y)",
      "",
      "        # Return false if x and y are already in same group.",
      "        if x == y:",
      "            return False",
      "",
      "        # Swap so that the rank of x is higher.",
      "        if self._rank[x] < self._rank[y]:",
      "            x, y = y, x",
      "            w = -w",
      "",
      "        # If the two trees are the same rank, the rank increases by 1 after merge.",
      "        if self._rank[x] == self._rank[y]:",
      "            self._rank[x] += 1",
      "",
      "        # Update parent.",
      "        self._parent[y] = x",
      "",
      "        # Update weight.",
      "        self._diff_weight[y] = w",
      "",
      "        # Successfully merged.",
      "        return True",
      "",
      "    def diff(self, x: int, y: int) -> T:",
      "        return self.weight(y) - self.weight(x)"
    ],
    "description": "WeightedUnionFindTree"
  },
  "Coordinate Comperss": {
    "prefix": "compress",
    "body": [
      "def compress(A: List[int]) -> List[int]:",
      "    X: List[int] = sorted(set(A))",
      "    D: Dict[int, int] = {x: i for i, x in enumerate(X)}",
      "    return list(map(lambda x: D[x], A))"
    ],
    "description": "Coordinate Comperss"
  },
  "Dijkstra Method": {
    "prefix": "dijkstra",
    "body": [
      "class Dijkstra:",
      "    \"\"\"Dijkstra Method",
      "",
      "    Dijkstra method implementation.",
      "",
      "    Attributes:",
      "        N (int): Number of the nodes in the graph.",
      "        graph (List[List[Tuple[int, int]]]): Adjacency-list representation of the graph.",
      "        distance (List[int]): A list retains distance of the shortest path from start",
      "                            to the node.",
      "        previous (List[int]): A list retains previous node index of the node on the",
      "                            shortest path.",
      "    \"\"\"",
      "",
      "    def __init__(self, graph: List[List[Tuple[int, int]]]):",
      "        \"\"\"Constructor",
      "",
      "        Construct dijkstra object.",
      "",
      "        Args:",
      "            graph (List[List[Tuple[int, int]]]): Adjacency-list representation of the",
      "                                                graph.",
      "",
      "        \"\"\"",
      "",
      "        # Copy the graph",
      "        self.graph: List[List[Tuple[int, int]]] = graph",
      "        self.N: int = len(graph)",
      "",
      "        # Initialize each list",
      "        self.distance: List[int] = [1 << 60 for i in range(self.N)]",
      "        self.previous: List[int] = [-1 for i in range(self.N)]",
      "",
      "    def search(self, start_node: int) -> Tuple[List[int], List[int]]:",
      "        \"\"\"Calculate distance of the shortest path from start_node to each nodes.",
      "",
      "        Args:",
      "            start_node (int): The index of the start node.",
      "",
      "        Returns:",
      "            List[int]: A list retains distance of the shortest path.",
      "            List[int]: A list retains previous node of the node on the shortest path.",
      "",
      "        \"\"\"",
      "        # Heap queue",
      "        candidate: List[Tuple[int, int]] = [(0, start_node)]",
      "        # Set zero to the distance of the start node.",
      "        self.distance[start_node] = 0",
      "",
      "        # Start to search dijkstra",
      "        while candidate:",
      "            d, node = heapq.heappop(candidate)",
      "",
      "            if d > self.distance[node]:",
      "                continue",
      "",
      "            for next_node, weight in self.graph[node]:",
      "                if self.distance[next_node] > self.distance[node] + weight:",
      "                    self.distance[next_node] = self.distance[node] + weight",
      "                    self.previous[next_node] = node",
      "                    heapq.heappush(candidate, (self.distance[next_node], next_node))",
      "",
      "        return (self.distance, self.previous)",
      "",
      "    def restore_path(self, end_node: int) -> List[int]:",
      "        \"\"\"Get shortest path.",
      "",
      "        Restore shortest path from start_node to end_node.",
      "",
      "        Args:",
      "            end_node (int): The index of the end node.",
      "",
      "        Returns:",
      "            List[int]: A list of the shortest path.",
      "",
      "        \"\"\"",
      "        path: List[int] = []",
      "        t: int = end_node",
      "        while t != -1:",
      "            path.append(t)",
      "            t = self.previous[t]",
      "",
      "        return list(reversed(path))  "
    ],
    "description": "Dijkstra Method"
  },
  "Graph": {
    "prefix": "graph",
    "body": ["graph: List[List[int]] = [[] for i in range(N)]"],
    "description": "Input adjacency-list representation of non-weighted graph."
  },
  "WeigtedGraph": {
    "prefix": "weighted_graph",
    "body": ["graph: List[List[Tuple[int, int]]] = [[] for i in range(N)]"],
    "description": "Input adjacency-list representation of weighted graph"
  }
}
